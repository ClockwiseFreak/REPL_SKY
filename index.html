<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>repl.it</title>
    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <div id="progressbar"></div>
    <div id="scrollPath"></div>
    <section>
      <h2>Creative Scroll Progress Bar</h2>
      <p>ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER
PETERSBURG VERSION 41c1837 – 2021-02-14
DR. GAVIN WOOD
FOUNDER, ETHEREUM & PARITY
GAVIN@PARITY.IO
Abstract. The blockchain paradigm when coupled with cryptographically-secured transactions has demonstrated its
utility through a number of projects, with Bitcoin being one of the most notable ones. Each such project can be seen as
a simple application on a decentralised, but singleton, compute resource. We can call this paradigm a transactional
singleton machine with shared-state.
Ethereum implements this paradigm in a generalised manner. Furthermore it provides a plurality of such resources,
each with a distinct state and operating code but able to interact through a message-passing framework with others.
We discuss its design, implementation issues, the opportunities it provides and the future hurdles we envisage.
1. Introduction
With ubiquitous internet connections in most places
of the world, global information transmission has become
incredibly cheap. Technology-rooted movements like Bitcoin have demonstrated through the power of the default,
consensus mechanisms, and voluntary respect of the social
contract, that it is possible to use the internet to make
a decentralised value-transfer system that can be shared
across the world and virtually free to use. This system can
be said to be a very specialised version of a cryptographically secure, transaction-based state machine. Follow-up
systems such as Namecoin adapted this original “currency
application” of the technology into other applications albeit
rather simplistic ones.
Ethereum is a project which attempts to build the generalised technology; technology on which all transactionbased state machine concepts may be built. Moreover it
aims to provide to the end-developer a tightly integrated
end-to-end system for building software on a hitherto unexplored compute paradigm in the mainstream: a trustful
object messaging compute framework.
1.1. Driving Factors. There are many goals of this
project; one key goal is to facilitate transactions between
consenting individuals who would otherwise have no means
to trust one another. This may be due to geographical
separation, interfacing difficulty, or perhaps the incompatibility, incompetence, unwillingness, expense, uncertainty,
inconvenience, or corruption of existing legal systems. By
specifying a state-change system through a rich and unambiguous language, and furthermore architecting a system
such that we can reasonably expect that an agreement will
be thus enforced autonomously, we can provide a means
to this end.
Dealings in this proposed system would have several
attributes not often found in the real world. The incorruptibility of judgement, often difficult to find, comes naturally
from a disinterested algorithmic interpreter. Transparency,
or being able to see exactly how a state or judgement came
about through the transaction log and rules or instructional
codes, never happens perfectly in human-based systems
since natural language is necessarily vague, information
is often lacking, and plain old prejudices are difficult to
shake.
Overall, we wish to provide a system such that users
can be guaranteed that no matter with which other individuals, systems or organisations they interact, they can
do so with absolute confidence in the possible outcomes
and how those outcomes might come about.
1.2. Previous Work. Buterin [2013a] first proposed the
kernel of this work in late November, 2013. Though now
evolved in many ways, the key functionality of a blockchain with a Turing-complete language and an effectively
unlimited inter-transaction storage capability remains unchanged.
Dwork and Naor [1992] provided the first work into the
usage of a cryptographic proof of computational expenditure (“proof-of-work”) as a means of transmitting a value
signal over the Internet. The value-signal was utilised here
as a spam deterrence mechanism rather than any kind
of currency, but critically demonstrated the potential for
a basic data channel to carry a strong economic signal,
allowing a receiver to make a physical assertion without
having to rely upon trust. Back [2002] later produced a
system in a similar vein.
The first example of utilising the proof-of-work as a
strong economic signal to secure a currency was by Vishnumurthy et al. [2003]. In this instance, the token was
used to keep peer-to-peer file trading in check, providing
“consumers” with the ability to make micro-payments to
“suppliers” for their services. The security model afforded
by the proof-of-work was augmented with digital signatures
and a ledger in order to ensure that the historical record
couldn’t be corrupted and that malicious actors could not
spoof payment or unjustly complain about service delivery. Five years later, Nakamoto [2008] introduced another
such proof-of-work-secured value token, somewhat wider in
scope. The fruits of this project, Bitcoin, became the first
widely adopted global decentralised transaction ledger.
Other projects built on Bitcoin’s success; the alt-coins
introduced numerous other currencies through alteration
to the protocol. Some of the best known are Litecoin and
Primecoin, discussed by Sprankel [2013]. Other projects
sought to take the core value content mechanism of the protocol and repurpose it; Aron [2012] discusses, for example,
1
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 2
the Namecoin project which aims to provide a decentralised
name-resolution system.
Other projects still aim to build upon the Bitcoin network itself, leveraging the large amount of value placed in
the system and the vast amount of computation that goes
into the consensus mechanism. The Mastercoin project,
first proposed by Willett [2013], aims to build a richer
protocol involving many additional high-level features on
top of the Bitcoin protocol through utilisation of a number
of auxiliary parts to the core protocol. The Coloured Coins
project, proposed by Rosenfeld et al. [2012], takes a similar
but more simplified strategy, embellishing the rules of a
transaction in order to break the fungibility of Bitcoin’s
base currency and allow the creation and tracking of tokens
through a special “chroma-wallet”-protocol-aware piece of
software.
Additional work has been done in the area with discarding the decentralisation foundation; Ripple, discussed by
Boutellier and Heinzen [2014], has sought to create a “federated” system for currency exchange, effectively creating
a new financial clearing system. It has demonstrated that
high efficiency gains can be made if the decentralisation
premise is discarded.
Early work on smart contracts has been done by Szabo
[1997] and Miller [1997]. Around the 1990s it became clear
that algorithmic enforcement of agreements could become a
significant force in human cooperation. Though no specific
system was proposed to implement such a system, it was
proposed that the future of law would be heavily affected
by such systems. In this light, Ethereum may be seen as a
general implementation of such a crypto-law system.
For a list of terms used in this paper, refer to Appendix
A.
2. The Blockchain Paradigm
Ethereum, taken as a whole, can be viewed as a
transaction-based state machine: we begin with a genesis state and incrementally execute transactions to morph
it into some current state. It is this current state which we
accept as the canonical “version” of the world of Ethereum.
The state can include such information as account balances, reputations, trust arrangements, data pertaining
to information of the physical world; in short, anything
that can currently be represented by a computer is admissible. Transactions thus represent a valid arc between two
states; the ‘valid’ part is important—there exist far more
invalid state changes than valid state changes. Invalid state
changes might, e.g., be things such as reducing an account
balance without an equal and opposite increase elsewhere.
A valid state transition is one which comes about through
a transaction. Formally:
(1) σt+1 ≡ Υ(σt, T)
where Υ is the Ethereum state transition function. In
Ethereum, Υ, together with σ are considerably more powerful than any existing comparable system; Υ allows components to carry out arbitrary computation, while σ allows
components to store arbitrary state between transactions.
Transactions are collated into blocks; blocks are chained
together using a cryptographic hash as a means of reference. Blocks function as a journal, recording a series of
transactions together with the previous block and an identifier for the final state (though do not store the final state
itself—that would be far too big). They also punctuate the
transaction series with incentives for nodes to mine. This
incentivisation takes place as a state-transition function,
adding value to a nominated account.
Mining is the process of dedicating effort (working) to
bolster one series of transactions (a block) over any other
potential competitor block. It is achieved thanks to a
cryptographically secure proof. This scheme is known as a
proof-of-work and is discussed in detail in section 11.5.
Formally, we expand to:
(2) σt+1 ≡ Π(σt, B)
(3) B ≡ (...,(T0, T1, ...), ...)
(4) Π(σ, B) ≡ Ω(B, Υ(Υ(σ, T0), T1)...)
Where Ω is the block-finalisation state transition function (a function that rewards a nominated party); B is this
block, which includes a series of transactions amongst some
other components; and Π is the block-level state-transition
function.
This is the basis of the blockchain paradigm, a model
that forms the backbone of not only Ethereum, but all
decentralised consensus-based transaction systems to date.
2.1. Value. In order to incentivise computation within the
network, there needs to be an agreed method for transmitting value. To address this issue, Ethereum has an intrinsic
currency, Ether, known also as ETH and sometimes referred
to by the Old English ¯D. The smallest subdenomination
of Ether, and thus the one in which all integer values of
the currency are counted, is the Wei. One Ether is defined
as being 1018 Wei. There exist other subdenominations of
Ether:
Multiplier Name
100 Wei
1012 Szabo
1015 Finney
1018 Ether
Throughout the present work, any reference to value,
in the context of Ether, currency, a balance or a payment,
should be assumed to be counted in Wei.
2.2. Which History? Since the system is decentralised
and all parties have an opportunity to create a new block
on some older pre-existing block, the resultant structure is
necessarily a tree of blocks. In order to form a consensus
as to which path, from root (the genesis block) to leaf (the
block containing the most recent transactions) through
this tree structure, known as the blockchain, there must
be an agreed-upon scheme. If there is ever a disagreement
between nodes as to which root-to-leaf path down the block
tree is the ‘best’ blockchain, then a fork occurs.
This would mean that past a given point in time (block),
multiple states of the system may coexist: some nodes believing one block to contain the canonical transactions,
other nodes believing some other block to be canonical,
potentially containing radically different or incompatible
transactions. This is to be avoided at all costs as the uncertainty that would ensue would likely kill all confidence
in the entire system.
The scheme we use in order to generate consensus is a
simplified version of the GHOST protocol introduced by
Sompolinsky and Zohar [2013]. This process is described
in detail in section 10.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 3
Sometimes, a path follows a new protocol from a particular height (block number). This document describes
one version of the protocol. In order to follow back the
history of a path, one must reference multiple versions of
this document.
3. Conventions
We use a number of typographical conventions for the
formal notation, some of which are quite particular to the
present work:
The two sets of highly structured, ‘top-level’, state values, are denoted with bold lowercase Greek letters. They
fall into those of world-state, which are denoted σ (or a
variant thereupon) and those of machine-state, µ.
Functions operating on highly structured values are
denoted with an upper-case Greek letter, e.g. Υ, the
Ethereum state transition function.
For most functions, an uppercase letter is used, e.g. C,
the general cost function. These may be subscripted to
denote specialised variants, e.g. CSSTORE, the cost function for the SSTORE operation. For specialised and possibly
externally defined functions, we may format as typewriter
text, e.g. the Keccak-256 hash function (as per version
3 of the winning entry to the SHA-3 contest by Bertoni
et al. [2011], rather than the final SHA-3 specification), is
denoted KEC (and generally referred to as plain Keccak).
Also, KEC512 refers to the Keccak-512 hash function.
Tuples are typically denoted with an upper-case letter,
e.g. T, is used to denote an Ethereum transaction. This
symbol may, if accordingly defined, be subscripted to refer
to an individual component, e.g. Tn, denotes the nonce
of said transaction. The form of the subscript is used to
denote its type; e.g. uppercase subscripts refer to tuples
with subscriptable components.
Scalars and fixed-size byte sequences (or, synonymously,
arrays) are denoted with a normal lower-case letter, e.g.
n is used in the document to denote a transaction nonce.
Those with a particularly special meaning may be Greek,
e.g. δ, the number of items required on the stack for a
given operation.
Arbitrary-length sequences are typically denoted as a
bold lower-case letter, e.g. o is used to denote the byte
sequence given as the output data of a message call. For
particularly important values, a bold uppercase letter may
be used.
Throughout, we assume scalars are non-negative integers and thus belong to the set N. The set of all byte
sequences is B, formally defined in Appendix B. If such
a set of sequences is restricted to those of a particular
length, it is denoted with a subscript, thus the set of all
byte sequences of length 32 is named B32 and the set of
all non-negative integers smaller than 2256 is named N256.
This is formally defined in section 4.3.
Square brackets are used to index into and reference
individual components or subsequences of sequences, e.g.
µs
[0] denotes the first item on the machine’s stack. For
subsequences, ellipses are used to specify the intended
range, to include elements at both limits, e.g. µm[0..31]
denotes the first 32 items of the machine’s memory.
In the case of the global state σ, which is a sequence of
accounts, themselves tuples, the square brackets are used
to reference an individual account.
When considering variants of existing values, we follow
the rule that within a given scope for definition, if we
assume that the unmodified ‘input’ value be denoted by
the placeholder  then the modified and utilisable value is
denoted as
0
, and intermediate values would be
∗
,
∗∗
&c. On very particular occasions, in order to maximise
readability and only if unambiguous in meaning, we may
use alpha-numeric subscripts to denote intermediate values,
especially those of particular note.
When considering the use of existing functions, given a
function f, the function f
∗ denotes a similar, element-wise
version of the function mapping instead between sequences.
It is formally defined in section 4.3.
We define a number of useful functions throughout. One
of the more common is `, which evaluates to the last item
in the given sequence:
(5) `(x) ≡ x[kxk − 1]
4. Blocks, State and Transactions
Having introduced the basic concepts behind Ethereum,
we will discuss the meaning of a transaction, a block and
the state in more detail.
4.1. World State. The world state (state), is a mapping between addresses (160-bit identifiers) and account
states (a data structure serialised as RLP, see Appendix
B). Though not stored on the blockchain, it is assumed
that the implementation will maintain this mapping in
a modified Merkle Patricia tree (trie, see Appendix D).
The trie requires a simple database backend that maintains a mapping of byte arrays to byte arrays; we name
this underlying database the state database. This has a
number of benefits; firstly the root node of this structure
is cryptographically dependent on all internal data and
as such its hash can be used as a secure identity for the
entire system state. Secondly, being an immutable data
structure, it allows any previous state (whose root hash
is known) to be recalled by simply altering the root hash
accordingly. Since we store all such root hashes in the
blockchain, we are able to trivially revert to old states.
The account state, σ[a], comprises the following four
fields:
nonce: A scalar value equal to the number of transactions sent from this address or, in the case
of accounts with associated code, the number of
contract-creations made by this account. For account of address a in state σ, this would be formally denoted σ[a]n.
balance: A scalar value equal to the number of Wei
owned by this address. Formally denoted σ[a]b.
storageRoot: A 256-bit hash of the root node of a
Merkle Patricia tree that encodes the storage contents of the account (a mapping between 256-bit
integer values), encoded into the trie as a mapping
from the Keccak 256-bit hash of the 256-bit integer
keys to the RLP-encoded 256-bit integer values.
The hash is formally denoted σ[a]s.
codeHash: The hash of the EVM code of this
account—this is the code that gets executed should
this address receive a message call; it is immutable
and thus, unlike all other fields, cannot be changed
after construction. All such code fragments are
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 4
contained in the state database under their corresponding hashes for later retrieval. This hash is
formally denoted σ[a]c, and thus the code may be
denoted as b, given that KEC(b) = σ[a]c.
Since we typically wish to refer not to the trie’s root
hash but to the underlying set of key/value pairs stored
within, we define a convenient equivalence:
(6) TRIE
L
∗
I (σ[a]s)

≡ σ[a]s
The collapse function for the set of key/value pairs in
the trie, L
∗
I
, is defined as the element-wise transformation
of the base function LI , given as:
(7) LI

(k, v)

≡

KEC(k), RLP(v)

where:
(8) k ∈ B32 ∧ v ∈ N
It shall be understood that σ[a]s is not a ‘physical’
member of the account and does not contribute to its later
serialisation.
If the codeHash field is the Keccak-256 hash of the
empty string, i.e. σ[a]c = KEC
()
, then the node represents
a simple account, sometimes referred to as a “non-contract”
account.
Thus we may define a world-state collapse function LS:
(9) LS(σ) ≡ {p(a) : σ[a] 6= ∅}
where
(10) p(a) ≡

KEC(a), RLP
(σ[a]n, σ[a]b, σ[a]s, σ[a]c)

This function, LS, is used alongside the trie function
to provide a short identity (hash) of the world state. We
assume:
(11) ∀a : σ[a] = ∅ ∨ (a ∈ B20 ∧ v(σ[a]))
where v is the account validity function:
(12) v(x) ≡ xn ∈ N256∧xb ∈ N256∧xs ∈ B32∧xc ∈ B32
An account is empty when it has no code, zero nonce
and zero balance:
(13)
EMPTY(σ, a) ≡ σ[a]c = KEC
()
∧σ[a]n = 0∧σ[a]b = 0
Even callable precompiled contracts can have an empty
account state. This is because their account states do not
usually contain the code describing its behavior.
An account is dead when its account state is non-existent
or empty:
(14) DEAD(σ, a) ≡ σ[a] = ∅ ∨ EMPTY(σ, a)
4.2. The Transaction. A transaction (formally, T) is a
single cryptographically-signed instruction constructed by
an actor externally to the scope of Ethereum. While it is
assumed that the ultimate external actor will be human in
nature, software tools will be used in its construction and
dissemination1
. There are two types of transactions: those
which result in message calls and those which result in
the creation of new accounts with associated code (known
informally as ‘contract creation’). Both types specify a
number of common fields:
nonce: A scalar value equal to the number of transactions sent by the sender; formally Tn.
gasPrice: A scalar value equal to the number of
Wei to be paid per unit of gas for all computation
costs incurred as a result of the execution of this
transaction; formally Tp.
gasLimit: A scalar value equal to the maximum
amount of gas that should be used in executing
this transaction. This is paid up-front, before any
computation is done and may not be increased
later; formally Tg.
to: The 160-bit address of the message call’s recipient or, for a contract creation transaction, ∅, used
here to denote the only member of B0 ; formally
Tt.
value: A scalar value equal to the number of Wei to
be transferred to the message call’s recipient or,
in the case of contract creation, as an endowment
to the newly created account; formally Tv.
v, r, s: Values corresponding to the signature of the
transaction and used to determine the sender of
the transaction; formally Tw, Tr and Ts. This is
expanded in Appendix F.
Additionally, a contract creation transaction contains:
init: An unlimited size byte array specifying the
EVM-code for the account initialisation procedure,
formally Ti.
init is an EVM-code fragment; it returns the body,
a second fragment of code that executes each time the
account receives a message call (either through a transaction or due to the internal execution of code). init is
executed only once at account creation and gets discarded
immediately thereafter.
In contrast, a message call transaction contains:
data: An unlimited size byte array specifying the
input data of the message call, formally Td.
Appendix F specifies the function, S, which maps transactions to the sender, and happens through the ECDSA of
the SECP-256k1 curve, using the hash of the transaction
(excepting the latter three signature fields) as the datum
to sign. For the present we simply assert that the sender
of a given transaction T can be represented with S(T).
(15)
LT (T) ≡
(
(Tn, Tp, Tg, Tt, Tv, Ti, Tw, Tr, Ts) if Tt = ∅
(Tn, Tp, Tg, Tt, Tv, Td, Tw, Tr, Ts) otherwise
Here, we assume all components are interpreted by the
RLP as integer values, with the exception of the arbitrary
length byte arrays Ti and Td.
(16) Tn ∈ N256 ∧ Tv ∈ N256 ∧ Tp ∈ N256 ∧
Tg ∈ N256 ∧ Tw ∈ N5 ∧ Tr ∈ N256 ∧
Ts ∈ N256 ∧ Td ∈ B ∧ Ti ∈ B
where
(17) Nn = {P : P ∈ N ∧ P < 2
n
}
The address hash Tt is slightly different: it is either a
20-byte address hash or, in the case of being a contractcreation transaction (and thus formally equal to ∅), it is
1Notably, such ‘tools’ could ultimately become so causally removed from their human-based initiation—or humans may become so
causally-neutral—that there could be a point at which they rightly be considered autonomous agents. e.g. contracts may offer bounties to
humans for being sent transactions to initiate their exe
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 5
the RLP empty byte sequence and thus the member of B0:
(18) Tt ∈
(
B20 if Tt 6= ∅
B0 otherwise
4.3. The Block. The block in Ethereum is the collection of relevant pieces of information (known as the block
header ), H, together with information corresponding to
the comprised transactions, T, and a set of other block
headers U that are known to have a parent equal to the
present block’s parent’s parent (such blocks are known as
ommers2
). The block header contains several pieces of
information:
parentHash: The Keccak 256-bit hash of the parent
block’s header, in its entirety; formally Hp.
ommersHash: The Keccak 256-bit hash of the ommers list portion of this block; formally Ho.
beneficiary: The 160-bit address to which all fees
collected from the successful mining of this block
be transferred; formally Hc.
stateRoot: The Keccak 256-bit hash of the root
node of the state trie, after all transactions are
executed and finalisations applied; formally Hr.
transactionsRoot: The Keccak 256-bit hash of the
root node of the trie structure populated with each
transaction in the transactions list portion of the
block; formally Ht.
receiptsRoot: The Keccak 256-bit hash of the root
node of the trie structure populated with the receipts of each transaction in the transactions list
portion of the block; formally He.
logsBloom: The Bloom filter composed from indexable information (logger address and log topics)
contained in each log entry from the receipt of
each transaction in the transactions list; formally
Hb.
difficulty: A scalar value corresponding to the difficulty level of this block. This can be calculated
from the previous block’s difficulty level and the
timestamp; formally Hd.
number: A scalar value equal to the number of ancestor blocks. The genesis block has a number of
zero; formally Hi.
gasLimit: A scalar value equal to the current limit
of gas expenditure per block; formally Hl.
gasUsed: A scalar value equal to the total gas used
in transactions in this block; formally Hg.
timestamp: A scalar value equal to the reasonable
output of Unix’s time() at this block’s inception;
formally Hs.
extraData: An arbitrary byte array containing data
relevant to this block. This must be 32 bytes or
fewer; formally Hx.
mixHash: A 256-bit hash which, combined with the
nonce, proves that a sufficient amount of computation has been carried out on this block; formally
Hm.
nonce: A 64-bit value which, combined with the mixhash, proves that a sufficient amount of computation has been carried out on this block; formally
Hn.
The other two components in the block are simply a list
of ommer block headers (of the same format as above),
BU and a series of the transactions, BT. Formally, we can
refer to a block B:
(19) B ≡ (BH, BT, BU)
4.3.1. Transaction Receipt. In order to encode information
about a transaction concerning which it may be useful
to form a zero-knowledge proof, or index and search, we
encode a receipt of each transaction containing certain information from its execution. Each receipt, denoted BR[i]
for the ith transaction, is placed in an index-keyed trie
and the root recorded in the header as He.
The transaction receipt, R, is a tuple of four items comprising: the cumulative gas used in the block containing
the transaction receipt as of immediately after the transaction has happened, Ru, the set of logs created through
execution of the transaction, Rl and the Bloom filter composed from information in those logs, Rb and the status
code of the transaction, Rz:
(20) R ≡ (Ru, Rb, Rl, Rz)
The function LR trivially prepares a transaction receipt
for being transformed into an RLP-serialised byte array:
(21) LR(R) ≡ (0 ∈ B256, Ru, Rb, Rl)
where 0 ∈ B256 replaces the pre-transaction state root that
existed in previous versions of the protocol.
We assert that the status code Rz is a non-negative
integer.
(22) Rz ∈ N
We assert that Ru, the cumulative gas used, is a nonnegative integer and that the logs Bloom, Rb, is a hash of
size 2048 bits (256 bytes):
(23) Ru ∈ N ∧ Rb ∈ B256
The sequence Rl is a series of log entries, (O0, O1, ...).
A log entry, O, is a tuple of the logger’s address, Oa, a
possibly empty series of 32-byte log topics, Ot and some
number of bytes of data, Od:
(24) O ≡ (Oa,(Ot0, Ot1, ...), Od)
(25) Oa ∈ B20 ∧ ∀x ∈ Ot : x ∈ B32 ∧ Od ∈ B
We define the Bloom filter function, M, to reduce a log
entry into a single 256-byte hash:
(26) M(O) ≡
_
x∈{Oa}∪Ot

M3:2048(x)

where M3:2048 is a specialised Bloom filter that sets
three bits out of 2048, given an arbitrary byte sequence.
It does this through taking the low-order 11 bits of each of
2ommer is a gender-neutral term to mean “sibling of parent”; see https://nonbinary.miraheze.org/wiki/Gender_neutral_language#Aunt.
2FUncle
311 bits = 22048, and the low-order 11 bits is the modulo 2048 of the operand, which is in this case is “each of the first three pairs of
bytes in a Keccak-256 hash of the byte sequence.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 6
the first three pairs of bytes in a Keccak-256 hash of the
byte sequence.3 Formally:
(27)M3:2048(x : x ∈ B) ≡ y : y ∈ B256 where:
(28) y = (0, 0, ..., 0) except:
(29) ∀i ∈ {0, 2, 4} : Bm(x,i)(y) = 1
(30) m(x, i) ≡ KEC(x)[i, i + 1] mod 2048
where B is the bit reference function such that Bj(x)
equals the bit of index j (indexed from 0) in the byte array
x.
4.3.2. Holistic Validity. We can assert a block’s validity
if and only if it satisfies several conditions: it must be internally consistent with the ommer and transaction block
hashes and the given transactions BT (as specified in sec
11), when executed in order on the base state σ (derived
from the final state of the parent block), result in a new
state of the identity Hr:
(31) Hr ≡ TRIE(LS(Π(σ, B))) ∧
Ho ≡ KEC(RLP(L
∗
H(BU))) ∧
Ht ≡ TRIE({∀i < kBTk, i ∈ N :
p(i, LT (BT[i]))}) ∧
He ≡ TRIE({∀i < kBRk, i ∈ N :
p(i, LR(BR[i]))}) ∧
Hb ≡
W
r∈BR

rb

where p(k, v) is simply the pairwise RLP transformation,
in this case, the first being the index of the transaction in
the block and the second being the transaction receipt:
(32) p(k, v) ≡

RLP(k), RLP(v)

Furthermore:
(33) TRIE(LS(σ)) = P(BH)Hr
Thus TRIE(LS(σ)) is the root node hash of the Merkle
Patricia tree structure containing the key-value pairs of
the state σ with values encoded using RLP, and P(BH) is
the parent block of B, defined directly.
The values stemming from the computation of transactions, specifically the transaction receipts, BR, and that
defined through the transaction’s state-accumulation function, Π, are formalised later in section 11.4.
4.3.3. Serialisation. The function LB and LH are the
preparation functions for a block and block header respectively. Much like the transaction receipt preparation
function LR, we assert the types and order of the structure
for when the RLP transformation is required:
LH(H) ≡ ( Hp, Ho, Hc, Hr, Ht, He, Hb, Hd,
Hi, Hl, Hg, Hs, Hx, Hm, Hn )
(34)
LB(B) ≡

LH(BH), L∗
T (BT), L∗
H(BU)

(35)
With L
∗
T and L
∗
H being element-wise sequence transformations, thus:
(36)
f
∗

(x0, x1, ...)

≡

f(x0), f(x1), ...
for any function f
The component types are defined thus:
(37) Hp ∈ B32 ∧ Ho ∈ B32 ∧ Hc ∈ B20 ∧
Hr ∈ B32 ∧ Ht ∈ B32 ∧ He ∈ B32 ∧
Hb ∈ B256 ∧ Hd ∈ N ∧ Hi ∈ N ∧
Hl ∈ N ∧ Hg ∈ N ∧ Hs ∈ N256 ∧
Hx ∈ B ∧ Hm ∈ B32 ∧ Hn ∈ B8
where
(38) Bn = {B : B ∈ B ∧ kBk = n}
We now have a rigorous specification for the construction of a formal block structure. The RLP function RLP
(see Appendix B) provides the canonical method for transforming this structure into a sequence of bytes ready for
transmission over the wire or storage locally.
4.3.4. Block Header Validity. We define P(BH) to be the
parent block of B, formally:
(39) P(H) ≡ B
0
: KEC(RLP(B
0
H)) = Hp
The block number is the parent’s block number incremented by one:
(40) Hi ≡ P(H)Hi + 1
The canonical difficulty of a block of header H is defined
as D(H):
(41)
D(H) ≡
(
D0 if Hi = 0
max
D0, P(H)Hd + x × ς2 + 

otherwise
where:
(42) D0 ≡ 131072
(43) x ≡

P(H)Hd
2048 
(44) ς2 ≡ max 
y −

Hs − P(H)Hs
9

, −99
y ≡
(
1 if kP(H)Uk = 0
2 otherwise
 ≡
j
2
bH0
i ÷100000c−2
k
(45)
H
0
i ≡ max(Hi − 5000000, 0)(46)
Note that D0 is the difficulty of the genesis block. The
Homestead difficulty parameter, ς2, is used to affect a dynamic homeostasis of time between blocks, as the time
between blocks varies, as discussed below, as implemented
in EIP-2 by Buterin [2015]. In the Homestead release,
the exponential difficulty symbol,  causes the difficulty to
slowly increase (every 100,000 blocks) at an exponential
rate, and thus increasing the block time difference, and
putting time pressure on transitioning to proof-of-stake.
This effect, known as the “difficulty bomb”, or “ice age”,
was explained in EIP-649 by Schoedon and Buterin [2017]
and delayed and implemented earlier in EIP-2. ς2 was also
modified in EIP-100 with the use of x, the adjustment
factor above, and the denominator 9, in order to target
the mean block time including uncle blocks by Buterin
[2016]. In the Byzantium release, with EIP-649, the ice age
was delayed by creating a fake block number, H0
i
, which
is obtained by subtracting three million4
from the actual
block number, which in other words reduced  and the
time difference between blocks, in order to allow more time
4five million since the Constantinople release as per EI
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 7
to develop proof-of-stake and preventing the network from
“freezing” up.
The canonical gas limit Hl of a block of header H must
fulfil the relation:
Hl < P(H)Hl +

P(H)Hl
1024 
(47) ∧
Hl > P(H)Hl −

P(H)Hl
1024 
∧
Hl > 5000
Hs is the timestamp (in Unix’s time()) of block H and
must fulfil the relation:
(48) Hs > P(H)Hs
This mechanism enforces a homeostasis in terms of the
time between blocks; a smaller period between the last two
blocks results in an increase in the difficulty level and thus
additional computation required, lengthening the likely
next period. Conversely, if the period is too large, the
difficulty, and expected time to the next block, is reduced.
The nonce, Hn, must satisfy the relations:
(49) n 6
2
256
Hd
∧ m = Hm
with (n, m) = PoW(Hn, Hn, d).
Where Hn is the new block’s header H, but without the
nonce and mix-hash components, d being the current DAG,
a large data set needed to compute the mix-hash, and PoW
is the proof-of-work function (see section 11.5): this evaluates to an array with the first item being the mix-hash, to
prove that a correct DAG has been used, and the second
item being a pseudo-random number cryptographically
dependent on H and d. Given an approximately uniform
distribution in the range [0, 2
64), the expected time to find
a solution is proportional to the difficulty, Hd.
This is the foundation of the security of the blockchain
and is the fundamental reason why a malicious node cannot propagate newly created blocks that would otherwise
overwrite (“rewrite”) history. Because the nonce must satisfy this requirement, and because its satisfaction depends
on the contents of the block and in turn its composed
transactions, creating new, valid, blocks is difficult and,
over time, requires approximately the total compute power
of the trustworthy portion of the mining peers.
Thus we are able to define the block header validity
function V (H):
V (H) ≡ n 6
2
256
Hd
(50) ∧ m = Hm ∧
Hd = D(H) ∧
Hg ≤ Hl ∧
Hl < P(H)Hl +

P(H)Hl
1024 
∧
Hl > P(H)Hl −

P(H)Hl
1024 
∧
Hl > 5000 ∧
Hs > P(H)Hs ∧
Hi = P(H)Hi + 1 ∧
kHxk ≤ 32
where (n, m) = PoW(Hn, Hn, d)
Noting additionally that extraData must be at most
32 bytes.
5. Gas and Payment
In order to avoid issues of network abuse and to sidestep
the inevitable questions stemming from Turing completeness, all programmable computation in Ethereum is subject
to fees. The fee schedule is specified in units of gas (see Appendix G for the fees associated with various computation).
Thus any given fragment of programmable computation
(this includes creating contracts, making message calls,
utilising and accessing account storage and executing operations on the virtual machine) has a universally agreed
cost in terms of gas.
Every transaction has a specific amount of gas associated with it: gasLimit. This is the amount of gas which
is implicitly purchased from the sender’s account balance.
The purchase happens at the according gasPrice, also
specified in the transaction. The transaction is considered invalid if the account balance cannot support such
a purchase. It is named gasLimit since any unused gas
at the end of the transaction is refunded (at the same
rate of purchase) to the sender’s account. Gas does not
exist outside of the execution of a transaction. Thus for
accounts with trusted code associated, a relatively high
gas limit may be set and left alone.
In general, Ether used to purchase gas that is not refunded is delivered to the beneficiary address, the address
of an account typically under the control of the miner.
Transactors are free to specify any gasPrice that they
wish, however miners are free to ignore transactions as
they choose. A higher gas price on a transaction will therefore cost the sender more in terms of Ether and deliver
a greater value to the miner and thus will more likely be
selected for inclusion by more miners. Miners, in general,
will choose to advertise the minimum gas price for which
they will execute transactions and transactors will be free
to canvas these prices in determining what gas price to
offer. Since there will be a (weighted) distribution of minimum acceptable gas prices, transactors will necessarily
have a trade-off to make between lowering the gas price
and maximising the chance that their transaction will be
mined in a timely manner.
6. Transaction Execution
The execution of a transaction is the most complex part
of the Ethereum protocol: it defines the state transition
function Υ. It is assumed that any transactions executed
first pass the initial tests of intrinsic validity. These include:
(1) The transaction is well-formed RLP, with no additional trailing bytes;
(2) the transaction signature is valid;
(3) the transaction nonce is valid (equivalent to the
sender account’s current nonce);
(4) the gas limit is no smaller than the intrinsic gas,
g0, used by the transaction; and
(5) the sender account balance contains at least the
cost, v0, required in up-front payment.
Formally, we consider the function Υ, with T being a
transaction and σ the state:
(51) σ
0 = Υ(σ, T)
Thus σ
0
is the post-transactional state. We also define
Υ
g
to evaluate to the amount of gas used in the execution
of a transaction, Υl
to evaluate to the transaction’s accrued
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 8
log items and Υz
to evaluate to the status code resulting
from the transaction. These will be formally defined later.
6.1. Substate. Throughout transaction execution, we accrue certain information that is acted upon immediately
following the transaction. We call this the accrued transaction substate, or accrued substate for short, and represent
it as A, which is a tuple:
(52) A ≡ (As, Al, At, Ar)
The tuple contents include As, the self-destruct set: a
set of accounts that will be discarded following the transaction’s completion. Al is the log series: this is a series of
archived and indexable ‘checkpoints’ in VM code execution that allow for contract-calls to be easily tracked by
onlookers external to the Ethereum world (such as decentralised application front-ends). At is the set of touched
accounts, of which the empty ones are deleted at the end
of a transaction. Finally there is Ar, the refund balance,
increased through using the SSTORE instruction in order
to reset contract storage to zero from some non-zero value.
Though not immediately refunded, it is allowed to partially
offset the total execution costs.
We define the empty accrued substate A
0
to have no
self-destructs, no logs, no touched accounts and a zero
refund balance:
(53) A
0 ≡ (∅,(), ∅, 0)
6.2. Execution. We define intrinsic gas g0, the amount of
gas this transaction requires to be paid prior to execution,
as follows:
g0 ≡
X
i∈Ti
,Td
(
Gtxdatazero if i = 0
Gtxdatanonzero otherwise
(54)
+
(
Gtxcreate if Tt = ∅
0 otherwise
(55)
(56) + Gtransaction
where Ti, Td means the series of bytes of the transaction’s associated data and initialisation EVM-code, depending on whether the transaction is for contract-creation
or message-call. Gtxcreate is added if the transaction is
contract-creating, but not if a result of EVM-code. G is
fully defined in Appendix G.
The up-front cost v0 is calculated as:
(57) v0 ≡ TgTp + Tv
The validity is determined as:
(58) S(T) 6= ∅ ∧
σ[S(T)] 6= ∅ ∧
Tn = σ[S(T)]n ∧
g0 6 Tg ∧
v0 6 σ[S(T)]b ∧
Tg 6 BHl − `(BR)u
Note the final condition; the sum of the transaction’s
gas limit, Tg, and the gas utilised in this block prior, given
by `(BR)u, must be no greater than the block’s gasLimit,
BHl
.
The execution of a valid transaction begins with an
irrevocable change made to the state: the nonce of the
account of the sender, S(T), is incremented by one and the
balance is reduced by part of the up-front cost, TgTp. The
gas available for the proceeding computation, g, is defined
as Tg − g0. The computation, whether contract creation
or a message call, results in an eventual state (which may
legally be equivalent to the current state), the change to
which is deterministic and never invalid: there can be no
invalid transactions from this point.
We define the checkpoint state σ0:
(59) σ0 ≡ σ except:
(60) σ0[S(T)]b ≡ σ[S(T)]b − TgTp
(61) σ0[S(T)]n ≡ σ[S(T)]n + 1
Evaluating σP from σ0 depends on the transaction
type; either contract creation or message call; we define
the tuple of post-execution provisional state σP , remaining
gas g
0
, accrued substate A and status code z:
(62)
(σP , g
0
, A, z) ≡



Λ4(σ0, S(T), To, g,
Tp, Tv, Ti, 0, ∅, >) if Tt = ∅
Θ4(σ0, S(T), To, Tt, Tt,
g, Tp, Tv, Tv, Td, 0, >) otherwise
where g is the amount of gas remaining after deducting
the basic amount required to pay for the existence of the
transaction:
(63) g ≡ Tg − g0
and To is the original transactor, which can differ from the
sender in the case of a message call or contract creation
not directly triggered by a transaction but coming from
the execution of EVM-code.
Note we use Θ4 and Λ4 to denote the fact that only the
first four components of the functions’ values are taken;
the final represents the message-call’s output value (a byte
array) and is unused in the context of transaction evaluation.
After the message call or contract creation is processed,
the refund counter has to be incremented for the accounts
that were self-destructed throughout its invocation.
(64) A
0
r ≡ Ar +
X
i∈As
Rselfdestruct
Then the state is finalised by determining the amount
to be refunded, g
∗
from the remaining gas, g
0
, plus some
allowance from the refund counter, to the sender at the
original rate.
(65) g
∗ ≡ g
0 + min j
Tg − g
0
2
k
, A0
r

The total refundable amount is the legitimately remaining gas g
0
, added to Ar, with the latter component being
capped up to a maximum of half (rounded down) of the
total amount used Tg − g
0
. Therefore, g
∗
is the total gas
that remains after the transaction has been executed.
The Ether for the gas is given to the miner, whose
address is specified as the beneficiary of the present block
B. So we define the pre-final state σ
∗
in terms of the
provisional state σP :
σ
∗
(66) ≡ σP except
σ
∗
[S(T)]b ≡ σP [S(T)]b + g
∗
(67) Tp
σ
∗
[m]b ≡ σP [m]b + (Tg − g
∗
(68) )Tp
(69) m ≡ BHc
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 9
The final state, σ
0
, is reached after deleting all accounts
that either appear in the self-destruct set or are touched
and empty:
σ
0 ≡ σ
∗
(70) except
∀i ∈ As : σ
0
(71) [i] = ∅
∀i ∈ At : σ
0
[i] = ∅ if DEAD(σ
∗
(72) , i)
And finally, we specify Υg
, the total gas used in this
transaction Υl
, the logs created by this transaction and
Υ
z
, the status code of this transaction:
Υ
g
(σ, T) ≡ Tg − g
∗
(73)
Υ
l
(74) (σ, T) ≡ Al
Υ
z
(75) (σ, T) ≡ z
These are used to help define the transaction receipt
and are also used later for state and nonce validation.
7. Contract Creation
There are a number of intrinsic parameters used when
creating an account: sender (s), original transactor (o),
available gas (g), gas price (p), endowment (v) together
with an arbitrary length byte array, i, the initialisation
EVM code, the present depth of the message-call/contractcreation stack (e), the salt for new account’s address (ζ)
and finally the permission to make modifications to the
state (w). The salt ζ might be missing (ζ = ∅); formally,
(76) ζ ∈ B32 ∪ B0
If the creation was caused by CREATE2, then ζ 6= ∅.
We define the creation function formally as the function
Λ, which evaluates from these values, together with the
state σ to the tuple containing the new state, remaining
gas, accrued transaction substate and an error message
(σ
0
, g0
, A, o), as in section 6:
(77) (σ
0
, g
0
, A, z, o) ≡ Λ(σ, s, o, g, p, v, i, e, ζ, w)
The address of the new account is defined as being the
rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the sender and the
account nonce. For CREATE2 the rule is different and is
described in EIP-1014. Combining the two cases, we define
the resultant address for the new account a:
(78) a ≡ A(s, σ[s]n − 1, ζ, i)
A(s, n, ζ, i) ≡ B96..255
KEC
B(s, n, ζ, i)

(79)
B(s, n, ζ, i) ≡
(
RLP
(s, n)

if ζ = ∅
(255) · s · ζ · KEC(i) otherwise
(80)
where · is the concatenation of byte arrays, Ba..b(X)
evaluates to a binary value containing the bits of indices
in the range [a, b] of the binary data X, and σ[x] is the
address state of x, or ∅ if none exists. Note we use one
fewer than the sender’s nonce value; we assert that we
have incremented the sender account’s nonce prior to this
call, and so the value used is the sender’s nonce at the
beginning of the responsible transaction or VM operation.
The account’s nonce is initially defined as one, the balance as the value passed, the storage as empty and the
code hash as the Keccak 256-bit hash of the empty string;
the sender’s balance is also reduced by the value passed.
Thus the mutated state becomes σ
∗
:
(81) σ
∗ ≡ σ except:
σ
∗
[a] =
1, v + v
0
, TRIE(∅), KEC
() (82)
σ
∗
[s] = (
∅ if σ[s] = ∅ ∧ v = 0
a
∗
otherwise
(83)
a
∗
(84) ≡ (σ[s]n, σ[s]b − v, σ[s]s, σ[s]c)
where v
0
is the account’s pre-existing value, in the event
it was previously in existence:
(85) v
0 ≡
(
0 if σ[a] = ∅
σ[a]b otherwise
Finally, the account is initialised through the execution
of the initialising EVM code i according to the execution
model (see section 9). Code execution can effect several
events that are not internal to the execution state: the
account’s storage can be altered, further accounts can be
created and further message calls can be made. As such,
the code execution function Ξ evaluates to a tuple of the resultant state σ
∗∗, available gas remaining g
∗∗, the accrued
substate A and the body code of the account o.
(86) (σ
∗∗
, g
∗∗, A, o) ≡ Ξ(σ
∗
, g, I, {s, a})
where I contains the parameters of the execution environment, that is:
(87) Ia ≡ a
(88) Io ≡ o
(89) Ip ≡ p
(90) Id ≡ ()
(91) Is ≡ s
(92) Iv ≡ v
(93) Ib ≡ i
(94) Ie ≡ e
(95) Iw ≡ w
Id evaluates to the empty tuple as there is no input data
to this call. IH has no special treatment and is determined
from the blockchain.
Code execution depletes gas, and gas may not go below
zero, thus execution may exit before the code has come
to a natural halting state. In this (and several other) exceptional cases we say an out-of-gas (OOG) exception has
occurred: The evaluated state is defined as being the empty
set, ∅, and the entire create operation should have no effect
on the state, effectively leaving it as it was immediately
prior to attempting the creation.
If the initialization code completes successfully, a final
contract-creation cost is paid, the code-deposit cost, c,
proportional to the size of the created contract’s code:
(96) c ≡ Gcodedeposit × kok
If there is not enough gas remaining to pay this, i.e.
g
∗∗ < c, then we also declare an out-of-gas exception.
The gas remaining will be zero in any such exceptional
condition, i.e. if the creation was conducted as the reception of a transaction, then this doesn’t affect payment of
the intrinsic cost of contract creation; it is paid regardless.
However, the value of the transaction is not transferred to
the aborted contract’s address when we are out-of-gas.
If such an exception does not occur, then the remaining
gas is refunded to the originator and the now-altered state
is allowed to persist. Thus formally, we may specify
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 10
resultant state, gas, accrued substate and status code as
(σ
0
, g0
, A, z) where:
g
0 ≡
(
0 if F
g
∗∗ − c otherwise
(97)
σ
0 ≡



σ if F
σ
∗∗ except:
σ
0
[a] = ∅ if DEAD(σ
∗∗, a)
σ
∗∗ except:
σ
0
[a]c = KEC(o) otherwise
(98)
z ≡
(
0 if σ
∗∗ = ∅ ∨ g
∗∗ < c
1 otherwise
(99)
where
F ≡

(σ
∗∗ = ∅ ∧ o = ∅) ∨ g
∗∗ < c ∨ kok > 24576
(100)
The exception in the determination of σ
0 dictates that
o, the resultant byte sequence from the execution of the
initialisation code, specifies the final body code for the
newly-created account.
Note that intention is that the result is either a successfully created new contract with its endowment, or no new
contract with no transfer of value.
7.1. Subtleties. Note that while the initialisation code
is executing, the newly created address exists but with
no intrinsic body code5
. Thus any message call received
by it during this time causes no code to be executed. If
the initialisation execution ends with a SELFDESTRUCT
instruction, the matter is moot since the account will be
deleted before the transaction is completed. For a normal
STOP code, or if the code returned is otherwise empty, then
the state is left with a zombie account, and any remaining
balance will be locked into the account forever.
8. Message Call
In the case of executing a message call, several parameters are required: sender (s), transaction originator (o),
recipient (r), the account whose code is to be executed (c,
usually the same as recipient), available gas (g), value (v)
and gas price (p) together with an arbitrary length byte
array, d, the input data of the call, the present depth of
the message-call/contract-creation stack (e) and finally the
permission to make modifications to the state (w).
Aside from evaluating to a new state and accrued
transaction substate, message calls also have an extra
component—the output data denoted by the byte array
o. This is ignored when executing transactions, however
message calls can be initiated due to VM-code execution
and in this case this information is used.
(101) (σ
0
, g
0
, A, z, o) ≡ Θ(σ, s, o, r, c, g, p, v, v, ˜ d, e, w)
Note that we need to differentiate between the value that
is to be transferred, v, from the value apparent in the
execution context, v˜, for the DELEGATECALL instruction.
We define σ1, the first transitional state as the original state but with the value transferred from sender to
recipient:
(102) σ1[r]b ≡ σ[r]b + v ∧ σ1[s]b ≡ σ[s]b − v
unless s = r.
Throughout the present work, it is assumed that if σ1[r]
was originally undefined, it will be created as an account
with no code or state and zero balance and nonce. Thus
the previous equation should be taken to mean:
(103) σ1 ≡ σ
0
1 except:
(104) σ1[s] ≡
(
∅ if σ
0
1[s] = ∅ ∧ v = 0
a1 otherwise
(105) a1 ≡

σ
0
1[s]n, σ
0
1[s]b − v, σ
0
1[s]s, σ
0
1[s]c

(106) and σ
0
1 ≡ σ except:
(107)



σ
0
1[r] ≡ (0, v, TRIE(∅), KEC(())) if σ[r] = ∅ ∧ v 6= 0
σ
0
1[r] ≡ ∅ if σ[r] = ∅ ∧ v = 0
σ
0
1[r] ≡ a
0
1 otherwise
(108) a
0
1 ≡ (σ[r]n, σ[r]b + v, σ[r]s, σ[r]c)
The account’s associated code (identified as the fragment whose Keccak hash is σ[c]c) is executed according to
the execution model (see section 9). Just as with contract
creation, if the execution halts in an exceptional fashion
(i.e. due to an exhausted gas supply, stack underflow, invalid jump destination or invalid instruction), then no gas
is refunded to the caller and the state is reverted to the
point immediately prior to balance transfer (i.e. σ).
σ
0 ≡
(
σ if σ
∗∗ = ∅
σ
∗∗ otherwise
(109)
g
0 ≡



0 if σ
∗∗ = ∅ ∧
o = ∅
g
∗∗ otherwise
(110)
z ≡
(
0 if σ
∗∗ = ∅
1 otherwise
(σ
∗∗
, g
∗∗ (111) , A, o) ≡ Ξ
(112) Ia ≡ r
(113) Io ≡ o
(114) Ip ≡ p
(115) Id ≡ d
(116) Is ≡ s
(117) Iv ≡ v˜
(118) Ie ≡ e
(119) Iw ≡ w
(120) t ≡ {s, r}
5During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while
CODESIZE should return the length of the initialization code (as defined in H.2
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 11
where
(121) Ξ ≡



ΞECREC(σ1, g, I, t) if r = 1
ΞSHA256(σ1, g, I, t) if r = 2
ΞRIP160(σ1, g, I, t) if r = 3
ΞID(σ1, g, I, t) if r = 4
ΞEXPMOD(σ1, g, I, t) if r = 5
ΞBN ADD(σ1, g, I, t) if r = 6
ΞBN MUL(σ1, g, I, t) if r = 7
ΞSNARKV(σ1, g, I, t) if r = 8
Ξ(σ1, g, I, t) otherwise
(122) Let KEC(Ib) = σ[c]c
It is assumed that the client will have stored the pair
(KEC(Ib), Ib) at some point prior in order to make the
determination of Ib feasible.
As can be seen, there are eight exceptions to the usage
of the general execution framework Ξ for evaluation of
the message call: these are eight so-called ‘precompiled’
contracts, meant as a preliminary piece of architecture
that may later become native extensions. The eight contracts in addresses 1 to 8 execute the elliptic curve public
key recovery function, the SHA2 256-bit hash scheme, the
RIPEMD 160-bit hash scheme, the identity function, arbitrary precision modular exponentiation, elliptic curve
addition, elliptic curve scalar multiplication and an elliptic
curve pairing check respectively.
Their full formal definition is in Appendix E.
9. Execution Model
The execution model specifies how the system state is
altered given a series of bytecode instructions and a small
tuple of environmental data. This is specified through a
formal model of a virtual state machine, known as the
Ethereum Virtual Machine (EVM). It is a quasi-Turingcomplete machine; the quasi qualification comes from the
fact that the computation is intrinsically bounded through
a parameter, gas, which limits the total amount of computation done.
9.1. Basics. The EVM is a simple stack-based architecture. The word size of the machine (and thus size of stack
items) is 256-bit. This was chosen to facilitate the Keccak256 hash scheme and elliptic-curve computations. The
memory model is a simple word-addressed byte array. The
stack has a maximum size of 1024. The machine also has
an independent storage model; this is similar in concept
to the memory but rather than a byte array, it is a wordaddressable word array. Unlike memory, which is volatile,
storage is non volatile and is maintained as part of the
system state. All locations in both storage and memory
are well-defined initially as zero.
The machine does not follow the standard von Neumann architecture. Rather than storing program code
in generally-accessible memory or storage, it is stored
separately in a virtual ROM interactable only through
a specialised instruction.
The machine can have exceptional execution for several
reasons, including stack underflows and invalid instructions. Like the out-of-gas exception, they do not leave
state changes intact. Rather, the machine halts immediately and reports the issue to the execution agent (either
the transaction processor or, recursively, the spawning
execution environment) which will deal with it separately.
9.2. Fees Overview. Fees (denominated in gas) are
charged under three distinct circumstances, all three as
prerequisite to the execution of an operation. The first
and most common is the fee intrinsic to the computation
of the operation (see Appendix G). Secondly, gas may be
deducted in order to form the payment for a subordinate
message call or contract creation; this forms part of the
payment for CREATE, CREATE2, CALL and CALLCODE.
Finally, gas may be paid due to an increase in the usage
of the memory.
Over an account’s execution, the total fee for memoryusage payable is proportional to smallest multiple of 32
bytes that are required such that all memory indices
(whether for read or write) are included in the range. This
is paid for on a just-in-time basis; as such, referencing an
area of memory at least 32 bytes greater than any previously indexed memory will certainly result in an additional
memory usage fee. Due to this fee it is highly unlikely
addresses will ever go above 32-bit bounds. That said,
implementations must be able to manage this eventuality.
Storage fees have a slightly nuanced behaviour—to incentivise minimisation of the use of storage (which corresponds directly to a larger state database on all nodes),
the execution fee for an operation that clears an entry in
the storage is not only waived, a qualified refund is given;
in fact, this refund is effectively paid up-front since the
initial usage of a storage location costs substantially more
than normal usage.
See Appendix H for a rigorous definition of the EVM
gas cost.
9.3. Execution Environment. In addition to the system state σ, and the remaining gas for computation g,
there are several pieces of important information used in
the execution environment that the execution agent must
provide; these are contained in the tuple I:
• Ia, the address of the account which owns the code
that is executing.
• Io, the sender address of the transaction that originated this execution.
• Ip, the price of gas in the transaction that originated this execution.
• Id, the byte array that is the input data to this
execution; if the execution agent is a transaction,
this would be the transaction data.
• Is, the address of the account which caused the
code to be executing; if the execution agent is a
transaction, this would be the transaction sender.
• Iv, the value, in Wei, passed to this account as
part of the same procedure as execution; if the
execution agent is a transaction, this would be the
transaction value.
• Ib, the byte array that is the machine code to be
executed.
• IH, the block header of the present block.
• Ie, the depth of the present message-call or
contract-creation (i.e. the number of CALLs or
CREATE(2)s being executed at present).
• Iw, the permission to make modifications to the
state.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 12
The execution model defines the function Ξ, which can
compute the resultant state σ
0
, the remaining gas g
0
, the
accrued substate A and the resultant output, o, given these
definitions. For the present context, we will define it as:
(123) (σ
0
, g
0
, A, o) ≡ Ξ(σ, g, I)
where we will remember that A, the accrued substate,
is defined as the tuple of the self-destructs set As, the log
series Al, the touched accounts At and the refund balance
Ar:
(124) A ≡ (As, Al, At, Ar)
9.4. Execution Overview. We must now define the Ξ
function. In most practical implementations this will be
modelled as an iterative progression of the pair comprising
the full system state, σ and the machine state, µ. Formally, we define it recursively with a function X. This
uses an iterator function O (which defines the result of a
single cycle of the state machine) together with functions
Z which determines if the present state is an exceptional
halting state of the machine and H, specifying the output
data of the instruction if and only if the present state is a
normal halting state of the machine.
The empty sequence, denoted (), is not equal to the
empty set, denoted ∅; this is important when interpreting
the output of H, which evaluates to ∅ when execution is to
continue but a series (potentially empty) when execution
should halt.
Ξ(σ, g, I, T) ≡ (σ
0
, µ
0
g
(125) , A, o)
(σ
0
, µ
0
, A, ..., o) ≡ X

(σ, µ, A0
, I)

(126)
(127) µg ≡ g
(128) µpc ≡ 0
(129) µm ≡ (0, 0, ...)
(130) µi ≡ 0
(131) µs ≡ ()
(132) µo ≡ ()
(133)
X

(σ, µ, A, I)

≡




∅, µ, A0
, I, ∅

if Z(σ, µ, I)

∅, µ
0
, A0
, I, o

if w = REVERT
O(σ, µ, A, I) · o if o 6= ∅
X

O(σ, µ, A, I)

otherwise
where
(134) o ≡ H(µ, I)
(135) (a, b, c, d) · e ≡ (a, b, c, d, e)
µ
0
(136) ≡ µ except:
µ
0
(137) g ≡ µg − C(σ, µ, I)
Note that, when we evaluate Ξ, we drop the fourth
element I
0
and extract the remaining gas µ
0
g
from the
resultant machine state µ
0
.
X is thus cycled (recursively here, but implementations
are generally expected to use a simple iterative loop) until
either Z becomes true indicating that the present state is
exceptional and that the machine must be halted and any
changes discarded or until H becomes a series (rather than
the empty set) indicating that the machine has reached a
controlled halt.
9.4.1. Machine State. The machine state µ is defined as
the tuple (g, pc, m, i, s) which are the gas available, the
program counter pc ∈ N256 , the memory contents, the
active number of words in memory (counting continuously
from position 0), and the stack contents. The memory
contents µm are a series of zeroes of size 2256
.
For the ease of reading, the instruction mnemonics,
written in small-caps (e.g. ADD), should be interpreted as
their numeric equivalents; the full table of instructions and
their specifics is given in Appendix H.
For the purposes of defining Z, H and O, we define w
as the current operation to be executed:
(138) w ≡
(
Ib[µpc] if µpc < kIbk
STOP otherwise
We also assume the fixed amounts of δ and α, specifying
the stack items removed and added, both subscriptable
on the instruction and an instruction cost function C evaluating to the full cost, in gas, of executing the given
instruction.
9.4.2. Exceptional Halting. The exceptional halting function Z is defined as:
(139)
Z(σ, µ, I) ≡ µg < C(σ, µ, I) ∨
δw = ∅ ∨
kµsk < δw ∨
(w = JUMP ∧ µs
[0] ∈/ D(Ib)) ∨
(w = JUMPI ∧ µs
[1] 6= 0 ∧
µs
[0] ∈/ D(Ib)) ∨
(w = RETURNDATACOPY∧
µs
[1] + µs
[2] > kµok) ∨
kµsk − δw + αw > 1024 ∨ (¬Iw ∧ W(w, µ))
where
(140)
W(w, µ) ≡ w ∈ {CREATE, CREATE2, SSTORE,
SELFDESTRUCT} ∨
LOG0 ≤ w ∧ w ≤ LOG4 ∨
w ∈ {CALL, CALLCODE} ∧ µs
[2] 6= 0
This states that the execution is in an exceptional halting state if there is insufficient gas, if the instruction is
invalid (and therefore its δ subscript is undefined), if there
are insufficient stack items, if a JUMP/JUMPI destination
is invalid, the new stack size would be larger than 1024 or
state modification is attempted during a static call. The astute reader will realise that this implies that no instruction
can, through its execution, cause an exceptional halt.
9.4.3. Jump Destination Validity. We previously used D
as the function to determine the set of valid jump destinations given the code that is being run. We define this
as any position in the code occupied by a JUMPDEST
instruction.
All such positions must be on valid instruction boundaries, rather than sitting in the data portion of PUSH
operations and must appear within the explicitly defined
portion of the code (rather than in the implicitly defined
STOP operations that trail it).
Formally:
(141) D(c) ≡ DJ (
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 13
where:
(142)
DJ (c, i) ≡



{} if i > kck
{i} ∪ DJ (c, N(i, c[i]))
if c[i] = JUMPDEST
DJ (c, N(i, c[i])) otherwise
where N is the next valid instruction position in the
code, skipping the data of a PUSH instruction, if any:
(143)
N(i, w) ≡



i + w − PUSH1 + 2
if w ∈ [PUSH1, PUSH32]
i + 1 otherwise
9.4.4. Normal Halting. The normal halting function H is
defined:
(144)
H(µ, I) ≡



HRETURN(µ) if w ∈ {RETURN, REVERT}
() if w ∈ {STOP, SELFDESTRUCT}
∅ otherwise
The data-returning halt operations, RETURN and
REVERT, have a special function HRETURN. Note also
the difference between the empty sequence and the empty
set as discussed here.
9.5. The Execution Cycle. Stack items are added or
removed from the left-most, lower-indexed portion of the
series; all other items remain unchanged:
O

(σ, µ, A, I)

≡ (σ
0
, µ
0
, A0
(145) , I)
(146) ∆ ≡ αw − δw
kµ
0
(147) sk ≡ kµsk + ∆
∀x ∈ [αw, kµ
0
sk) : µ
0
s
[x] ≡ µs
(148) [x − ∆]
The gas is reduced by the instruction’s gas cost and
for most instructions, the program counter increments on
each cycle, for the three exceptions, we assume a function
J, subscripted by one of two instructions, which evaluates
to the according value:
µ
0
(149) g ≡ µg − C(σ, µ, I)
µ
0
pc ≡



JJUMP(µ) if w = JUMP
JJUMPI(µ) if w = JUMPI
N(µpc, w) otherwise
(150)
In general, we assume the memory, self-destruct set and
system state don’t change:
µ
0
(151) m ≡ µm
µ
0
i ≡ µi
(152)
A
0
(153) ≡ A
σ
0
(154) ≡ σ
However, instructions do typically alter one or several
components of these values. Altered components listed by
instruction are noted in Appendix H, alongside values for
α and δ and a formal description of the gas requirements.
10. Blocktree to Blockchain
The canonical blockchain is a path from root to leaf
through the entire block tree. In order to have consensus
over which path it is, conceptually we identify the path
that has had the most computation done upon it, or, the
heaviest path. Clearly one factor that helps determine the
heaviest path is the block number of the leaf, equivalent
to the number of blocks, not counting the unmined genesis
block, in the path. The longer the path, the greater the
total mining effort that must have been done in order to
arrive at the leaf. This is akin to existing schemes, such as
that employed in Bitcoin-derived protocols.
Since a block header includes the difficulty, the header
alone is enough to validate the computation done. Any
block contributes toward the total computation or total
difficulty of a chain.
Thus we define the total difficulty of block B recursively
as:
Bt ≡ B
0
(155) t + Bd
B
0
(156) ≡ P(BH)
As such given a block B, Bt is its total difficulty, B
0
is
its parent block and Bd is its difficulty.
11. Block Finalisation
The process of finalising a block involves four stages:
(1) Validate (or, if mining, determine) ommers;
(2) validate (or, if mining, determine) transactions;
(3) apply rewards;
(4) verify (or, if mining, compute a valid) state and
block nonce.
11.1. Ommer Validation. The validation of ommer
headers means nothing more than verifying that each ommer header is both a valid header and satisfies the relation
of Nth-generation ommer to the present block where N ≤ 6.
The maximum of ommer headers is two. Formally:
(157) kBUk 6 2
^
U∈BU
V (U) ∧ k(U, P(BH)H, 6)
where k denotes the “is-kin” property:
(158)
k(U, H, n) ≡



false if n = 0
s(U, H)
∨ k(U, P(H)H, n − 1) otherwise
and s denotes the “is-sibling” property:
(159)
s(U, H) ≡ (P(H) = P(U) ∧ H 6= U ∧ U /∈ B(H)U)
where B(H) and P(H) are the block and the parent block
of the corresponding header H respectively.
11.2. Transaction Validation. The given gasUsed
must correspond faithfully to the transactions listed: BHg,
the total gas used in the block, must be equal to the
accumulated gas used according to the final transaction:
(160) BHg = `(R)
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 14
11.3. Reward Application. The application of rewards
to a block involves raising the balance of the accounts of
the beneficiary address of the block and each ommer by a
certain amount. We raise the block’s beneficiary account
by Rblock; for each ommer, we raise the block’s beneficiary
by an additional 1
32 of the block reward and the beneficiary of the ommer gets rewarded depending on the block
number. Formally we define the function Ω:
(161)
Ω(B, σ) ≡ σ
0
: σ
0 = σ except:
σ
0
[BHc]b = σ[BHc]b +

1 + kBUk
32 
(162) Rblock
(163)
∀U ∈ BU :
σ
0
[Uc] = (
∅ if σ[Uc] = ∅ ∧ R = 0
a
0
otherwise
a
0
(164) ≡ (σ[Uc]n, σ[Uc]b + R, σ[Uc]s, σ[Uc]c)
R ≡

1 + 1
8
(Ui − BHi)

(165) Rblock
If there are collisions of the beneficiary addresses between ommers and the block (i.e. two ommers with the
same beneficiary address or an ommer with the same beneficiary address as the present block), additions are applied
cumulatively.
We define the block reward in Ether:
(166) Let Rblock = 1018 ×



5 if Hi < 4370000
3 if Hi < 7280000
2 otherwise
11.4. State & Nonce Validation. We may now define
the function, Γ, that maps a block B to its initiation state:
(167)
Γ(B) ≡
(
σ0 if P(BH) = ∅
σi : TRIE(LS(σi)) = P(BH)Hr
otherwise
Here, TRIE(LS(σi)) means the hash of the root node of
a trie of state σi; it is assumed that implementations will
store this in the state database, which is trivial and efficient
since the trie is by nature an immutable data structure.
And finally we define Φ, the block transition function,
which maps an incomplete block B to a complete block
B
0
:
Φ(B) ≡ B
0
: B
0 = B
∗
(168) except:
B
0
n = n : x 6
2
256
Hd
(169)
B
0
m = m with (x, m) = PoW(B
∗
(170) n, n, d)
B
∗ ≡ B except: B
∗
(171) r = r(Π(Γ(B), B))
With d being a dataset as specified in appendix J.
As specified at the beginning of the present work, Π is
the state-transition function, which is defined in terms of
Ω, the block finalisation function and Υ, the transactionevaluation function, both now well-defined.
As previously detailed, R[n]z, R[n]l and R[n]u are the
nth corresponding status code, logs and cumulative gas
used after each transaction (R[n]b, the fourth component
in the tuple, has already been defined in terms of the logs).
We also define the nth state σ[n], which is defined simply
as the state resulting from applying the corresponding
transaction to the state resulting from the previous transaction (or the block’s initial state in the case of the first
such transaction):
(172) σ[n] = (
Γ(B) if n < 0
Υ(σ[n − 1], BT[n]) otherwise
In the case of BR[n]u, we take a similar approach defining each item as the gas used in evaluating the corresponding transaction summed with the previous item (or zero,
if it is the first), giving us a running total:
(173) R[n]u =



0 if n < 0
Υ
g
(σ[n − 1], BT[n])
+R[n − 1]u otherwise
For R[n]l, we utilise the Υl
function that we conveniently defined in the transaction execution function.
(174) R[n]l = Υl
(σ[n − 1], BT[n])
We define R[n]z in a similar manner.
(175) R[n]z = Υz
(σ[n − 1], BT[n])
Finally, we define Π as the new state given the block reward function Ω applied to the final transaction’s resultant
state, `(σ):
(176) Π(σ, B) ≡ Ω(B, `(σ))
Thus the complete block-transition mechanism is defined, except for PoW, the proof-of-work function.
11.5. Mining Proof-of-Work. The mining proof-ofwork (PoW) exists as a cryptographically secure nonce
that proves beyond reasonable doubt that a particular
amount of computation has been expended in the determination of some token value n. It is utilised to enforce
the blockchain security by giving meaning and credence
to the notion of difficulty (and, by extension, total difficulty). However, since mining new blocks comes with
an attached reward, the proof-of-work not only functions
as a method of securing confidence that the blockchain
will remain canonical into the future, but also as a wealth
distribution mechanism.
For both reasons, there are two important goals of the
proof-of-work function; firstly, it should be as accessible as
possible to as many people as possible. The requirement
of, or reward from, specialised and uncommon hardware
should be minimised. This makes the distribution model
as open as possible, and, ideally, makes the act of mining a
simple swap from electricity to Ether at roughly the same
rate for anyone around the world.
Secondly, it should not be possible to make super-linear
profits, and especially not so with a high initial barrier.
Such a mechanism allows a well-funded adversary to gain
a troublesome amount of the network’s total mining power
and as such gives them a super-linear reward (thus skewing
distribution in their favour) as well as reducing the network
security.
One plague of the Bitcoin world is ASICs. These are
specialised pieces of compute hardware that exist only to
do a single task (Smith [1997]). In Bitcoin’s case the task is
the SHA256 hash function (Courtois et al. [2014]). While
ASICs exist for a proof-of-work function, both goals are
placed in jeopardy. Because of this, a proof-of-work function that is ASIC-resistant (i.e. difficult or economically
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 15
inefficient to implement in specialised compute hardware)
has been identified as the proverbial silver bullet.
Two directions exist for ASIC resistance; firstly make
it sequential memory-hard, i.e. engineer the function such
that the determination of the nonce requires a lot of memory and bandwidth such that the memory cannot be used
in parallel to discover multiple nonces simultaneously. The
second is to make the type of computation it would need to
do general-purpose; the meaning of “specialised hardware”
for a general-purpose task set is, naturally, general purpose
hardware and as such commodity desktop computers are
likely to be pretty close to “specialised hardware” for the
task. For Ethereum 1.0 we have chosen the first path.
More formally, the proof-of-work function takes the
form of PoW:
(177)
m = Hm ∧ n 6
2
256
Hd
with (m, n) = PoW(Hn, Hn, d)
Where Hn is the new block’s header but without the
nonce and mix-hash components; Hn is the nonce of the
header; d is a large data set needed to compute the mixHash and Hd is the new block’s difficulty value (i.e. the
block difficulty from section 10). PoW is the proof-of-work
function which evaluates to an array with the first item
being the mixHash and the second item being a pseudorandom number cryptographically dependent on H and d.
The underlying algorithm is called Ethash and is described
below.
11.5.1. Ethash. Ethash is the PoW algorithm for Ethereum
1.0. It is the latest version of Dagger-Hashimoto, introduced by Buterin [2013b] and Dryja [2014], although it
can no longer appropriately be called that since many of
the original features of both algorithms were drastically
changed with R&D from February 2015 until May 4 2015
(Jentzsch [2015]). The general route that the algorithm
takes is as follows:
There exists a seed which can be computed for each
block by scanning through the block headers up until that
point. From the seed, one can compute a pseudorandom
cache, Jcacheinit bytes in initial size. Light clients store
the cache. From the cache, we can generate a dataset,
Jdatasetinit bytes in initial size, with the property that
each item in the dataset depends on only a small number
of items from the cache. Full clients and miners store the
dataset. The dataset grows linearly with time.
Mining involves grabbing random slices of the dataset
and hashing them together. Verification can be done with
low memory by using the cache to regenerate the specific
pieces of the dataset that you need, so you only need to
store the cache. The large dataset is updated once every
Jepoch blocks, so the vast majority of a miner’s effort will
be reading the dataset, not making changes to it. The
mentioned parameters as well as the algorithm is explained
in detail in appendix J.
12. Implementing Contracts
There are several patterns of contracts engineering that
allow particular useful behaviours; two of these that we
will briefly discuss are data feeds and random numbers.
12.1. Data Feeds. A data feed contract is one which provides a single service: it gives access to information from
the external world within Ethereum. The accuracy and
timeliness of this information is not guaranteed and it is
the task of a secondary contract author—the contract that
utilises the data feed—to determine how much trust can
be placed in any single data feed.
The general pattern involves a single contract within
Ethereum which, when given a message call, replies with
some timely information concerning an external phenomenon. An example might be the local temperature of New
York City. This would be implemented as a contract that
returned that value of some known point in storage. Of
course this point in storage must be maintained with the
correct such temperature, and thus the second part of the
pattern would be for an external server to run an Ethereum
node, and immediately on discovery of a new block, creates
a new valid transaction, sent to the contract, updating said
value in storage. The contract’s code would accept such
updates only from the identity contained on said server.
12.2. Random Numbers. Providing random numbers
within a deterministic system is, naturally, an impossible
task. However, we can approximate with pseudo-random
numbers by utilising data which is generally unknowable
at the time of transacting. Such data might include the
block’s hash, the block’s timestamp and the block’s beneficiary address. In order to make it hard for malicious miners
to control those values, one should use the BLOCKHASH
operation in order to use hashes of the previous 256 blocks
as pseudo-random numbers. For a series of such numbers,
a trivial solution would be to add some constant amount
and hashing the result.
13. Future Directions
The state database won’t be forced to maintain all past
state trie structures into the future. It should maintain
an age for each node and eventually discard nodes that
are neither recent enough nor checkpoints. Checkpoints,
or a set of nodes in the database that allow a particular
block’s state trie to be traversed, could be used to place a
maximum limit on the amount of computation needed in
order to retrieve any state throughout the blockchain.
Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download
to act as a full, mining, node. A compressed archive of the
trie structure at given points in time (perhaps one in every
10,000th block) could be maintained by the peer network,
effectively recasting the genesis block. This would reduce
the amount to be downloaded to a single archive plus a
hard maximum limit of blocks.
Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven’t sent/received a
transaction in some constant amount of blocks could be
thrown out, reducing both Ether-leakage and the growth
of the state database.
13.1. Scalability. Scalability remains an eternal concern.
With a generalised state transition function, it becomes difficult to partition and parallelise transactions to apply the
divide-and-conquer strategy. Unaddressed, the dynamic
value-range of the system remains essentially fixed and as
the average transaction value increases, the less valuable of
them become ignored, being economically pointless to include in the main ledger. However, several strategies exist
that may potentially be exploited to provide a considerably
more scalable protocol.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 16
Some form of hierarchical structure, achieved by either
consolidating smaller lighter-weight chains into the main
block or building the main block through the incremental combination and adhesion (through proof-of-work) of
smaller transaction sets may allow parallelisation of transaction combination and block-building. Parallelism could
also come from a prioritised set of parallel blockchains,
consolidating each block and with duplicate or invalid
transactions thrown out accordingly.
Finally, verifiable computation, if made generally available and efficient enough, may provide a route to allow the
proof-of-work to be the verification of final state.
14. Conclusion
We have introduced, discussed and formally defined the
protocol of Ethereum. Through this protocol the reader
may implement a node on the Ethereum network and join
others in a decentralised secure social operating system.
Contracts may be authored in order to algorithmically
specify and autonomously enforce rules of interaction.
15. Acknowledgements
Many thanks to Aeron Buchanan for authoring the
Homestead revisions, Christoph Jentzsch for authoring the
Ethash algorithm and Yoichi Hirai for doing most of the
EIP-150 changes. Important maintenance, useful corrections and suggestions were provided by a number of others
from the Ethereum DEV organisation and Ethereum community at large including Gustav Simonsson, Pawe l Bylica,
Jutta Steiner, Nick Savers, Viktor Tr´on, Marko Simovic,
Giacomo Tazzari and, of course, Vitalik Buterin.
16. Availability
The source of this paper is maintained at https:
//github.com/ethereum/yellowpaper/. An autogenerated PDF is located at https://ethereum.github.
io/yellowpaper/paper.pdf.
References
Jacob Aron. BitCoin software finds new life. New Scientist,
213(2847):20, 2012. URL http://www.sciencedirect.
com/science/article/pii/S0262407912601055.
Adam Back. Hashcash - Amortizable Publicly Auditable
Cost-Functions, 2002. URL http://www.hashcash.org/
papers/amortizable.pdf.
Guido Bertoni, Joan Daemen, Michal Peeters, and
Gilles Van Assche. The KECCAK SHA-3 submission, 2011. URL https://keccak.team/files/
Keccak-submission-3.pdf.
Roman Boutellier and Mareike Heinzen. Pirates, Pioneers, Innovators and Imitators. In Growth Through
Innovation, pages 85–96. Springer, 2014. URL https:
//www.springer.com/gb/book/9783319040158.
Vitalik Buterin. Ethereum: A Next-Generation Smart
Contract and Decentralized Application Platform,
2013a. URL https://github.com/ethereum/wiki/
wiki/White-Paper.
Vitalik Buterin. Dagger: A Memory-Hard to Compute,
Memory-Easy to Verify Scrypt Alternative, 2013b. URL
http://www.hashcash.org/papers/dagger.html.
Vitalik Buterin. EIP-2: Homestead hard-fork changes,
2015. URL https://github.com/ethereum/EIPs/
blob/master/EIPS/eip-2.md.
Vitalik Buterin. EIP-100: Change difficulty adjustment to target mean block time including uncles,
April 2016. URL https://github.com/ethereum/EIPs/
blob/master/EIPS/eip-100.md.
Nicolas T. Courtois, Marek Grajek, and Rahul Naik.
Optimizing SHA256 in Bitcoin Mining, pages 131–
144. Springer Berlin Heidelberg, Berlin, Heidelberg, 2014. ISBN 978-3-662-44893-9. doi: 10.
1007/978-3-662-44893-9 12. URL https://doi.org/10.
1007/978-3-662-44893-9_12.
B.A. Davey and H.A. Priestley. Introduction to lattices
and order. 2nd ed. Cambridge: Cambridge University
Press, 2nd ed. edition, 2002. ISBN 0-521-78451-4/pbk.
Thaddeus Dryja. Hashimoto: I/O bound proof of
work, 2014. URL http://diyhpl.us/~bryan/papers2/
bitcoin/meh/hashimoto.pdf.
Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In In 12th Annual International Cryptology Conference, pages 139–
147, 1992. URL http://www.wisdom.weizmann.ac.il/
~naor/PAPERS/pvp.pdf.
Phong Vo Glenn Fowler, Landon Curt Noll. FowlerNollVo hash function, 1991. URL http://www.isthe.com/
chongo/tech/comp/fnv/index.html.
Nils Gura, Arun Patel, Arvinderpal Wander, Hans Eberle,
and Sheueling Chang Shantz. Comparing elliptic curve
cryptography and RSA on 8-bit CPUs. In Cryptographic
Hardware and Embedded Systems-CHES 2004, pages
119–132. Springer, 2004. URL https://www.iacr.org/
archive/ches2004/31560117/31560117.pdf.
Christoph Jentzsch. Commit date for ethash, 2015. URL
https://github.com/ethereum/yellowpaper/commit/
77a8cf2428ce245bf6e2c39c5e652ba58a278666#
commitcomment-24644869.
Don Johnson, Alfred Menezes, and Scott Vanstone. The Elliptic Curve Digital Signature Algorithm (ECDSA), 2001. URL https:
//web.archive.org/web/20170921160141/http://
cs.ucsb.edu/~koc/ccs130h/notes/ecdsa-cert.pdf.
Accessed 21 September 2017, but the original link was
inaccessible on 19 October 2017. Refer to section 6.2 for
ECDSAPUBKEY, and section 7 for ECDSASIGN and
ECDSARECOVER.
Sergio Demian Lerner. Strict Memory Hard Hashing Functions, 2014. URL http://www.hashcash.org/papers/
memohash.pdf.
Mark Miller. The Future of Law. In paper delivered at the Extro 3 Conference (August
9), 1997. URL https://drive.google.com/file/d/
0Bw0VXJKBgYPMS0J2VGIyWWlocms/edit?usp=sharing.
Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash
system, 2008. URL http://www.bitcoin.org/bitcoin.
pdf.
Meni Rosenfeld, Yoni Assia, Vitalik Buterin, m liorhakiLior, Oded Leiba, Assaf Shomer, and Eliran Zach. Colored Coins Protocol Specification,
2012. URL https://github.com/Colored-Coins/
Colored-Coins-Protocol-Specification.
Afri Schoedon and Vitalik Buterin. EIP-649: Metropolis difficulty bomb delay and block reward reduction,
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 17
June 2017. URL https://github.com/ethereum/EIPs/
blob/master/EIPS/eip-649.md.
Michael John Sebastian Smith. Application-Specific
Integrated Circuits. Addison-Wesley, 1997. ISBN
0201500221.
Yonatan Sompolinsky and Aviv Zohar. Accelerating bitcoin’s transaction processing. fast money grows on trees,
not chains, 2013. URL https://eprint.iacr.org/
2013/881.
Simon Sprankel. Technical Basis of Digital Currencies,
2013. URL http://www.coderblog.de/wp-content/
uploads/technical-basis-of-digital-currencies.
pdf.
Nick Szabo. Formalizing and securing relationships on public networks. First Monday, 2(9),
1997. URL http://firstmonday.org/ojs/index.php/
fm/article/view/548.
Vivek Vishnumurthy, Sangeeth Chandrakumar, and
Emin Gn Sirer. KARMA: A secure economic framework
for peer-to-peer resource sharing, 2003. URL https://
www.cs.cornell.edu/people/egs/papers/karma.pdf.
J. R. Willett. MasterCoin Complete Specification, 2013.
URL https://github.com/mastercoin-MSC/spec.
Appendix A. Terminology
External Actor: A person or other entity able to interface to an Ethereum node, but external to the world of
Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain
and associated state. Has one (or more) intrinsic Accounts.
Address: A 160-bit code used for identifying Accounts.
Account: Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state.
They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them.
Though homogenous, it makes sense to distinguish between two practical types of account: those with empty
associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with
non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a
single Address that identifies it.
Transaction: A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous
Object. Transactions are recorded into each block of the blockchain.
Autonomous Object: A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic
address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated
only as the Storage State of that account.
Storage State: The information particular to a given Account that is maintained between the times that the
Account’s associated EVM Code runs.
Message: Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either
through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the
Transaction.
Message Call: The act of passing a message from one Account to another. If the destination account is associated
with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted
upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM
operation.
Gas: The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to
and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is
set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.
Contract: Informal term used to mean both a piece of EVM Code that may be associated with an Account or an
Autonomous Object.
Object: Synonym for Autonomous Object.
App: An end-user-visible application hosted in the Ethereum Browser.
Ethereum Browser: (aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified
browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum
protocol.
Ethereum Virtual Machine: (aka EVM) The virtual machine that forms the key part of the execution model
for an Account’s associated EVM Code.
Ethereum Runtime Environment: (aka ERE) The environment which is provided to an Autonomous Object
executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for
certain I/O instructions including CALL & CREATE.
EVM Code: The bytecode that the EVM can natively execute. Used to formally specify the meaning and
ramifications of a message to an Account.
EVM Assembly: The human-readable form of EVM-code.
LLL: The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general
low-level language toolkit for trans-compiling to.
Appendix B. Recursive Length Prefix
This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 18
We define the set of possible structures T:
(178) T ≡ L ] B
(179) L ≡ {t : t = (t[0], t[1], ...) ∧ ∀n < ktk : t[n] ∈ T}
(180) B ≡ {b : b = (b[0], b[1], ...) ∧ ∀n < kbk : b[n] ∈ O}
Where O is the set of (8-bit) bytes. Thus B is the set of all sequences of bytes (otherwise known as byte arrays, and
a leaf if imagined as a tree), L is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if
imagined as a tree) and T is the set of all byte arrays and such structural sequences. The disjoint union ] is needed only
to distinguish the empty byte array () ∈ B from the empty list () ∈ L, which are encoded differently as defined below; as
common, we will abuse notation and leave the disjoint union indices implicit, inferable from context.
We define the RLP function as RLP through two sub-functions, the first handling the instance when the value is a byte
array, the second when it is a sequence of further values:
(181) RLP(x) ≡
(
Rb(x) if x ∈ B
Rl(x) otherwise
If the value to be serialised is a byte array, the RLP serialisation takes one of three forms:
• If the byte array contains solely a single byte and that single byte is less than 128, then the input is exactly equal
to the output.
• If the byte array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to
the length of the byte array plus 128.
• Otherwise, the output is equal to the input, provided that it contains fewer than 264 bytes, prefixed by the
minimal-length byte array which when interpreted as a big-endian integer is equal to the length of the input byte
array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 183.
Byte arrays containing 264 or more bytes cannot be encoded. This restriction ensures that the first byte of the encoding
of a byte array is always below 192, and thus it can be readily distinguished from the encodings of sequences in L.
Formally, we define Rb:
Rb(x) ≡



x if kxk = 1 ∧ x[0] < 128
(128 + kxk) · x else if kxk < 56

183 +

BE(kxk)



· BE(kxk) · x else if kxk < 2
64
∅ otherwise
(182)
BE(x) ≡ (b0, b1, ...) : b0 6= 0 ∧ x =
kbX
k−1
n=0
bn · 256kbk−1−n
(183)
(184) (x1, ..., xn) · (y1, ..., ym) = (x1, ..., xn, y1, ..., ym)
Thus BE is the function that expands a non-negative integer value to a big-endian byte array of minimal length and
the dot operator performs sequence concatenation.
If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:
• If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal
to that concatenation prefixed by the byte equal to the length of this byte array plus 192.
• Otherwise, the output is equal to the concatenated serialisations, provided that they contain fewer than 264 bytes,
prefixed by the minimal-length byte array which when interpreted as a big-endian integer is equal to the length
of the concatenated serialisations byte array, which is itself prefixed by the number of bytes required to faithfully
encode this length value plus 247.
Sequences whose concatenated serialized items contain 264 or more bytes cannot be encoded. This restriction ensures
that the first byte of the encoding does not exceed 255 (otherwise it would not be a byte).
Thus we finish by formally defining Rl:
Rl(x) ≡



(192 + ks(x)k) · s(x) if s(x) 6= ∅ ∧ ks(x)k < 56

247 +

BE(ks(x)k)



· BE(ks(x)k) · s(x) else if s(x) 6= ∅ ∧ ks(x)k < 2
64
∅ otherwise
(185)
s(x) ≡
(
RLP(x[0]) · RLP(x[1]) · ... if ∀i : RLP(x[i]) 6= ∅
∅ otherwise
(186)
If RLP is used to encode a scalar, defined only as a non-negative integer (in N, or in Nx for any x), it must be encoded
as the shortest byte array whose big-endian interpretation is the scalar. Thus the RLP of some non-negative integer i is
defined as:
(187) RLP(i : i ∈ N) ≡ RLP(BE(i))
When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte
sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data,
dismissing it completel
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 19
There is no specific canonical encoding format for signed or floating-point values.
Appendix C. Hex-Prefix Encoding
Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to
store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates
between node types.
It is defined as the function HP which maps from a sequence of nibbles (represented by the set Y) together with a
boolean value to a sequence of bytes (represented by the set B):
HP(x, t) : x ∈ Y ≡
(
(16f(t), 16x[0] + x[1], 16x[2] + x[3], ...) if kxk is even
(16(f(t) + 1) + x[0], 16x[1] + x[2], 16x[3] + x[4], ...) otherwise
(188)
f(t) ≡
(
2 if t 6= 0
0 otherwise
(189)
Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the
second-lowest encoding the flag t. The low nibble of the first byte is zero in the case of an even number of nibbles and the
first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining
bytes.
Appendix D. Modified Merkle Patricia Tree
The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary
data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and
arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms
of the protocol specification, is to provide a single value that identifies a given set of key-value pairs, which may be either
a 32-byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the
structure of the trie in a manner that allows effective and efficient realisation of the protocol.
Formally, we assume the input value I, a set containing pairs of byte sequences with unique keys:
(190) I = {(k0 ∈ B, v0 ∈ B),(k1 ∈ B, v1 ∈ B), ...}
When considering such a sequence, we use the common numeric subscript notation to refer to a tuple’s key or value,
thus:
(191) ∀I ∈ I : I ≡ (I0, I1)
Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume
big-endian. Thus:
y(I) = {(k
0
0 ∈ Y, v0 ∈ B),(k
0
(192) 1 ∈ Y, v1 ∈ B), ...}
∀n : ∀i < 2kknk : k
0
n[i] ≡
(
bkn[i ÷ 2] ÷ 16c if i is even
kn[bi ÷ 2c] mod 16 otherwise
(193)
We define the function TRIE, which evaluates to the root of the trie that represents this set when encoded in this
structure:
(194) TRIE(I) ≡ KEC(c(I, 0))
We also assume a function n, the trie’s node cap function. When composing a node, we use RLP to encode the
structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store
the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference.
Thus we define in terms of c, the node composition function:
(195) n(I, i) ≡



() if I = ∅
c(I, i) if kc(I, i)k < 32
KEC(c(I, i)) otherwise
In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair.
The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree).
Unlike a radix tree, in the case of multiple keys sharing the same prefix or in the case of a single key having a unique
suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each
of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
Leaf: A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the
accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the
second parameter to the function is required to be 1.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 20
Extension: A two-item structure whose first item corresponds to a series of nibbles of size greater than one that
are shared by at least two distinct keys past the accumulation of the keys of nibbles and the keys of branches as
traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is
required to be 0.
Branch: A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for
the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and
thus a key being ended at this point in its traversal.
A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We
may formally define this structure with the structural composition function c:
(196)
c(I, i) ≡



RLP
HP(I0[i..(kI0k − 1)], 1), I1

if kIk = 1 where ∃I : I ∈ I
RLP
HP(I0[i..(j − 1)], 0), n(I, j)

if i 6= j where j = max{x : ∃l : klk = x ∧ ∀I ∈ I : I0[0..(x − 1)] = l}
RLP
(u(0), u(1), ..., u(15), v)

otherwise where u(j) ≡ n({I : I ∈ I ∧ I0[i] = j}, i + 1)
v =
(
I1 if ∃I : I ∈ I ∧ kI0k = i
() otherwise
D.1. Trie Database. Thus no explicit assumptions are made concerning what data is stored and what is not, since
that is an implementation-specific consideration; we simply define the identity function mapping the key-value set I
to a 32-byte hash and assert that only a single such hash exists for any I, which though not strictly true is accurate
within acceptable precision given the Keccak hash’s collision resistance. In reality, a sensible implementation will not fully
recompute the trie root hash for each set.
A reasonable implementation will maintain a database of nodes determined from the computation of various tries or,
more formally, it will memoise the function c. This strategy uses the nature of the trie to both easily recall the contents of
any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship,
Merkle-proofs may be constructed with an O(log N) space requirement that can demonstrate a particular leaf must exist
within a trie of a given root hash.
Appendix E. Precompiled Contracts
For each precompiled contract, we make use of a template function, ΞPRE, which implements the out-of-gas checking.
(197) ΞPRE(σ, g, I, T) ≡
(
(∅, 0, A0
,()) if g < gr
(σ, g − gr, A0
, o) otherwise
The precompiled contracts each use these definitions and provide specifications for the o (the output data) and gr, the
gas requirements.
We define ΞECREC as a precompiled contract for the elliptic curve digital signature algorithm (ECDSA) public key
recovery function (ecrecover). See Appendix F for the definition of the function ECDSARECOVER. We also define d to be
the input data, well-defined for an infinite length by appending zeroes as required. In the case of an invalid signature
(ECDSARECOVER(h, v, r, s) = ∅), we return no output.
(198) ΞECREC ≡ ΞPRE where:
(199) gr = 3000
kok =
(
0 if ECDSARECOVER(h, v, r, s) = ∅
32 otherwise
(200)
(201) if kok = 32 :
(202) o[0..11] = 0
o[12..31] = KEC
ECDSARECOVER(h, v, r, s)

(203) [12..31] where:
(204) d[0..(kIdk − 1)] = Id
(205) d[kIdk..] = (0, 0, ...)
(206) h = d[0..31]
(207) v = d[32..63]
(208) r = d[64..95]
(209) s = d[96..127]
We define ΞSHA256 and ΞRIP160 as precompiled contracts implementing the SHA2-256 and RIPEMD-160 hash functions
respectively. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of wor
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 21
(210) ΞSHA256 ≡ ΞPRE where:
gr = 60 + 12l
kIdk
32
m
(211)
(212) o[0..31] = SHA256(Id)
(213) ΞRIP160 ≡ ΞPRE where:
gr = 600 + 120l
kIdk
32
m
(214)
(215) o[0..11] = 0
(216) o[12..31] = RIPEMD160(Id)
For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and
SHA2-256 of the form:
(217) SHA256(i ∈ B) ≡ o ∈ B32
(218) RIPEMD160(i ∈ B) ≡ o ∈ B20
The fourth contract, the identity function ΞID simply defines the output as the input:
(219) ΞID ≡ ΞPRE where:
gr = 15 + 3l
kIdk
32
m
(220)
(221) o = Id
The fifth contract performs arbitrary-precision exponentiation under modulo. Here, 00
is taken to be one, and x mod 0
is zero for all x. The first word in the input specifies the number of bytes that the first non-negative integer B occupies.
The second word in the input specifies the number of bytes that the second non-negative integer E occupies. The third
word in the input specifies the number of bytes that the third non-negative integer M occupies. These three words are
followed by B, E and M. The rest of the input is discarded. Whenever the input is too short, the missing bytes are
considered to be zero. The output is encoded big-endian into the same format as M’s.
(222) ΞEXPMOD ≡ ΞPRE except:
gr =
$
f

max(`M, `B)

max(`
0
E, 1)
Gquaddivisor %
(223)
f(x) ≡



x
2
if x ≤ 64

x
2
4

+ 96x − 3072 if 64 < x ≤ 1024

x
2
16
+ 480x − 199680 otherwise
(224)
`
0
E =



0 if `E ≤ 32 ∧ E = 0
blog2
(E)c if `E ≤ 32 ∧ E 6= 0
8(`E − 32) + blog2
(i[(96 + `B)..(127 + `B)])c if 32 < `E ∧ i[(96 + `B)..(127 + `B)] 6= 0
8(`E − 32) otherwise
(225)
o =

B
E mod M

(226) ∈ N8`M
(227) `B ≡ i[0..31]
(228) `E ≡ i[32..63]
(229) `M ≡ i[64..95]
(230) B ≡ i[96..(95 + `B)]
(231) E ≡ i[(96 + `B)..(95 + `B + `E)]
(232) M ≡ i[(96 + `B + `E)..(95 + `B + `E + `M)]
i[x] ≡
(
Id[x] if x < kIdk
0 otherwise
(233)
E.1. zkSNARK Related Precompiled Contracts. We choose two numbers, both of which are prime.
(234) p ≡ 21888242871839275222246405745257275088696311157297823662689037894645226208583
(235) q ≡ 21888242871839275222246405745257275088548364400416034343698204186575808495617
Since p is a prime number, {0, 1, . . . , p − 1} forms a field with addition and multiplication modulo p. We call this field Fp
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 22
We define a set C1 with
(236) C1 ≡ {(X, Y ) ∈ Fp × Fp | Y
2 = X
3 + 3} ∪ {(0, 0)}
We define a binary operation + on C1 for distinct elements (X1, Y1),(X2, Y2) with
(X1, Y1) + (X2, Y2) ≡
(
(X, Y ) if X1 6= X2
(0, 0) otherwise
(237)
λ ≡
Y2 − Y1
X2 − X1
X ≡ λ
2 − X1 − X2
Y ≡ λ(X1 − X) − Y1
In the case where (X1, Y1) = (X2, Y2), we define + on C1 with
(X1, Y1) + (X2, Y2) ≡
(
(X, Y ) if Y1 6= 0
(0, 0) otherwise
(238)
λ ≡
3X
2
1
2Y1
X ≡ λ
2 − 2X1
Y ≡ λ(X1 − X) − Y1
(C1, +) is known to form a group. We define scalar multiplication · with
(239) n · P ≡ (0, 0) + P + · · · + P
| {z }
n
for a natural number n and a point P in C1.
We define P1 to be a point (1, 2) on C1. Let G1 be the subgroup of (C1, +) generated by P1. G1 is known to be a
cyclic group of order q. For a point P in G1, we define logP1
(P) to be the smallest natural number n satisfying n · P1 = P.
logP1
(P) is at most q − 1.
Let Fp2 be a field Fp[i]/(i
2 + 1). We define a set C2 with
(240) C2 ≡ {(X, Y ) ∈ Fp2 × Fp2 | Y
2 = X
3 + 3(i + 9)−1
} ∪ {(0, 0)}
We define a binary operation + and scalar multiplication · with the same equations (237), (238) and (239). (C2, +) is also
known to be a group. We define P2 in C2 with
(241) P2 ≡ (11559732032986387107991004021392285783925812861821192530917403151452391805634 × i
+10857046999023057135944570762232829481370756359578518086990519993285655852781,
4082367875863433681332203403145435568316851327593401208105741076214120093531 × i
+8495653923123431417604973247489272438418190587263600148770280649306958101930)
We define G2 to be the subgroup of (C2, +) generated by P2. G2 is known to be the only cyclic group of order q on C2.
For a point P in G2, we define logP2
(P) be the smallest natural number n satisfying n · P2 = P. With this definition,
logP2
(P) is at most q − 1.
Let GT be the multiplicative abelian group underlying Fq
12 . It is known that a non-degenerate bilinear map
e : G1 × G2 → GT exists. This bilinear map is a type three pairing. There are several such bilinear maps, it does not
matter which is chosen to be e. Let PT = e(P1, P2), a be a set of k points in G1, and b be a set of k points in G2. It
follows from the definition of a pairing that the following are equivalent
logP1
(a1) × logP2
(b1) + · · · + logP1
(ak) × logP2
(242) (bk) ≡ 1 mod q
Yk
i=0
(243) e (ai, bi) = PT
Thus the pairing operation provides a method to verify (242).
A 32 byte number x ∈ P256 might and might not represent an element of Fp.
(244) δp(x) ≡
(
x if x < p
∅ otherwise
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 23
A 64 byte data x ∈ B512 might and might not represent an element of G1.
δ1(x) ≡
(
g1 if g1 ∈ G1
∅ otherwise
(245)
g1 ≡
(
(x, y) if x 6= ∅ ∧ y 6= ∅
∅ otherwise
(246)
(247) x ≡ δp(x[0..31])
(248) y ≡ δp(x[32..63])
A 128 byte data x ∈ B1024 might and might not represent an element of G2.
δ2(x) ≡
(
g2 if g2 ∈ G2
∅ otherwise
(249)
g2 ≡
(
((x0i + y0),(x1i + y1)) if x0 6= ∅ ∧ y0 6= ∅ ∧ x1 6= ∅ ∧ y1 6= ∅
∅ otherwise
(250)
(251) x0 ≡ δp(x[0..31])
(252) y0 ≡ δp(x[32..63])
(253) x1 ≡ δp(x[64..95])
(254) y1 ≡ δp(x[96..127])
We define ΞSNARKV as a precompiled contract which checks if (242) holds, for intended use in zkSNARK verification.
(255) ΞSNARKV ≡ ΞPRE except:
ΞSNARKV(σ, g, I) =
∅, 0, A0
,()
(256) if F
(257) F ≡ (kIdk mod 192 6= 0 ∨ (∃j. aj = ∅ ∨ bj = ∅))
k =
kIdk
192
(258)
(259) gr = 80000k + 100000
o[0..31] ≡
(
0x0000000000000000000000000000000000000000000000000000000000000001 if v ∧ ¬F
0x0000000000000000000000000000000000000000000000000000000000000000 if ¬v ∧ ¬F
(260)
v ≡ (logP1
(a1) × logP2
(b1) + · · · + logP1
(ak) × logP2
(261) (bk) ≡ 1 mod q)
(262) a1 ≡ δ1(Id[0..63])
(263) b1 ≡ δ2(Id[64..191])
.
.
.
(264) ak ≡ δ1(Id[(kIdk − 192)..(kIdk − 129)])
(265) bk ≡ δ2(Id[(kIdk − 128)..(kIdk − 1)])
We define a precompiled contract for addition on G1.
(266) ΞBN ADD ≡ ΞBN PRE except:
ΞBN ADD(σ, g, I) =
∅, 0, A0
,()
(267) if x = ∅ ∨ y = ∅
(268) gr = 500
o ≡ δ
−1
1
(269) (x + y) where + is the group operation in G1
x ≡ δ1

I¯d[0..63]
(270)
y ≡ δ1

I¯d[64..127]
(271)
I¯d[x] ≡
(
Id[x] if x < kIdk
0 otherwise
(272)
We define a precompiled contract for scalar multiplication on G1, where I¯d is defined in (272).
(273) ΞBN MUL ≡ ΞPRE except:
ΞBN MUL(σ, g, I) =
∅, 0, A0
,()
(274) if x = ∅
(275) gr = 40000
o ≡ δ
−1
1
(276) (n · x) where · is the scalar multiplication in G1
x ≡ δ1

I¯d[0..63]
(277)
n ≡ I¯ (278) d[6
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 24
Appendix F. Signing Transactions
Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve as described
by Courtois et al. [2014], and is implemented similarly to as described by Gura et al. [2004] on p. 9 of 15, para. 3.
It is assumed that the sender has a valid private key pr, which is a randomly selected positive integer (represented as a
byte array of length 32 in big-endian form) in the range [1, secp256k1n − 1].
We assume the existence of functions ECDSAPUBKEY, ECDSASIGN and ECDSARECOVER. These are formally defined in the
literature, e.g. by Johnson et al. [2001].
(279) ECDSAPUBKEY(pr ∈ B32) ≡ pu ∈ B64
(280) ECDSASIGN(e ∈ B32, pr ∈ B32) ≡ (v ∈ B1, r ∈ B32, s ∈ B32)
(281) ECDSARECOVER(e ∈ B32, v ∈ B1, r ∈ B32, s ∈ B32) ≡ pu ∈ B64
Where pu is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive
integers each < 2
256), pr is the private key, a byte array of size 32 (or a single positive integer in the aforementioned
range) and e is the hash of the transaction, h(T). It is assumed that v is the ‘recovery identifier’. The recovery identifier
is a 1 byte value specifying the parity and finiteness of the coordinates of the curve point for which r is the x-value; this
value is in the range of [27, 30], however we declare the upper two possibilities, representing infinite values, invalid. The
value 27 represents an even y value and 28 represents an odd y value.
We declare that an ECDSA signature is invalid unless all the following conditions are true6
:
(282) 0 < r < secp256k1n
(283) 0 < s < secp256k1n ÷ 2 + 1
(284) v ∈ {27, 28}
where:
(285) secp256k1n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
For a given private key, pr, the Ethereum address A(pr) (a 160-bit value) to which it corresponds is defined as the
rightmost 160-bits of the Keccak hash of the corresponding ECDSA public key:
(286) A(pr) = B96..255
KEC
ECDSAPUBKEY(pr)

The message hash, h(T), to be signed is the Keccak hash of the transaction. Two different flavors of signing schemes
are available. One operates without the latter three signature components, formally described as Tr, Ts and Tw. The
other operates on nine elements:
LS(T) ≡
(
(Tn, Tp, Tg, Tt, Tv, p) if v ∈ {27, 28}
(Tn, Tp, Tg, Tt, Tv, p, chain id,(),()) otherwise
(287)
where
p ≡
(
Ti if Tt = 0
Td otherwise
(288) h(T) ≡ KEC(LS(T))
The signed transaction G(T, pr) is defined as:
(289) G(T, pr) ≡ T except:
(290) (Tw, Tr, Ts) = ECDSASIGN(h(T), pr)
Reiterating from previously:
(291) Tr = r
(292) Ts = s
Tw is either the recovery identifier or ‘chain identifier doubled plus 35 or 36’. In the second case, where v is the chain
identifier doubled plus 35 or 36, the values 35 and 36 assume the role of the ‘recovery identifier’ by specifying the parity
of y, with the value 35 representing an even value and 36 representing an odd value.
We may then define the sender function S of the transaction as:
S(T) ≡ B96..255
KEC
ECDSARECOVER(h(T), v0, Tr, Ts)
 (293)
v0 ≡
(
Tw if Tw ∈ {27, 28}
28 − (Tw mod 2) otherwise
(294)
The assertion that the sender of a signed transaction equals the address of the signer should be self-evident:
(295) ∀T : ∀pr : S(G(T, pr)) ≡ A(pr)
6A signature of a transaction can be valid not only with a recovery identifier but with some other numbers. See how the component Tw
of a transaction is interpre
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 25
Appendix G. Fee Schedule
The fee schedule G is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract
operations that a transaction may effect.
Name Value Description*
Gzero 0 Nothing paid for operations of the set Wzero.
Gbase 2 Amount of gas to pay for operations of the set Wbase.
Gverylow 3 Amount of gas to pay for operations of the set Wverylow.
Glow 5 Amount of gas to pay for operations of the set Wlow.
Gmid 8 Amount of gas to pay for operations of the set Wmid.
Ghigh 10 Amount of gas to pay for operations of the set Whigh.
Gextcode 700 Amount of gas to pay for an EXTCODESIZE operation.
Gextcodehash 700 Amount of gas to pay for an EXTCODEHASH operation.
Gbalance 700 Amount of gas to pay for a BALANCE operation.
Gsload 800 Paid for a SLOAD operation.
Gjumpdest 1 Paid for a JUMPDEST operation.
Gsset 20000 Paid for an SSTORE operation when the storage value is set to non-zero from zero.
Gsreset 5000 Paid for an SSTORE operation when the storage value’s zeroness remains unchanged or
is set to zero.
Rsclear 15000 Refund given (added into refund counter) when the storage value is set to zero from
non-zero.
Rselfdestruct 24000 Refund given (added into refund counter) for self-destructing an account.
Gselfdestruct 5000 Amount of gas to pay for a SELFDESTRUCT operation.
Gcreate 32000 Paid for a CREATE operation.
Gcodedeposit 200 Paid per byte for a CREATE operation to succeed in placing code into state.
Gcall 700 Paid for a CALL operation.
Gcallvalue 9000 Paid for a non-zero value transfer as part of the CALL operation.
Gcallstipend 2300 A stipend for the called contract subtracted from Gcallvalue for a non-zero value transfer.
Gnewaccount 25000 Paid for a CALL or SELFDESTRUCT operation which creates an account.
Gexp 10 Partial payment for an EXP operation.
Gexpbyte 50 Partial payment when multiplied by dlog256(exponent)e for the EXP operation.
Gmemory 3 Paid for every additional word when expanding memory.
Gtxcreate 32000 Paid by all contract-creating transactions after the Homestead transition.
Gtxdatazero 4 Paid for every zero byte of data or code for a transaction.
Gtxdatanonzero 16 Paid for every non-zero byte of data or code for a transaction.
Gtransaction 21000 Paid for every transaction.
Glog 375 Partial payment for a LOG operation.
Glogdata 8 Paid for each byte in a LOG operation’s data.
Glogtopic 375 Paid for each topic of a LOG operation.
Gsha3 30 Paid for each SHA3 operation.
Gsha3word 6 Paid for each word (rounded up) for input data to a SHA3 operation.
Gcopy 3 Partial payment for *COPY operations, multiplied by words copied, rounded up.
Gblockhash 20 Payment for BLOCKHASH operation.
Gquaddivisor 20 The quadratic coefficient of the input sizes of the exponentiation-over-modulo precompiled
contract.
Appendix H. Virtual Machine Specification
When interpreting 256-bit binary values as integers, the representation is big-endian.
When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE)
20 bytes are used and the leftmost 12 are discarded or filled with zeroes, thus the integer values (when the bytes are
interpreted as big-endian) are equivalent.
H.1. Gas Cost. The general gas cost function, C, is defined as:
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 26
(296)
C(σ, µ, I) ≡ Cmem(µ
0
i
)−Cmem(µi
) +



CSSTORE(σ, µ) if w = SSTORE
Gexp if w = EXP ∧ µs
[1] = 0
Gexp + Gexpbyte × (1 + blog256(µs
[1])c) if w = EXP ∧ µs
[1] > 0
Gverylow + Gcopy × dµs
[2] ÷ 32e if w = CALLDATACOPY ∨
CODECOPY ∨ RETURNDATACOPY
Gextcode + Gcopy × dµs
[3] ÷ 32e if w = EXTCODECOPY
Glog + Glogdata × µs
[1] if w = LOG0
Glog + Glogdata × µs
[1] + Glogtopic if w = LOG1
Glog + Glogdata × µs
[1] + 2Glogtopic if w = LOG2
Glog + Glogdata × µs
[1] + 3Glogtopic if w = LOG3
Glog + Glogdata × µs
[1] + 4Glogtopic if w = LOG4
CCALL(σ, µ) if w = CALL ∨ CALLCODE ∨
DELEGATECALL
CSELFDESTRUCT(σ, µ) if w = SELFDESTRUCT
Gcreate if w = CREATE
Gcreate + Gsha3word × dµs
[2] ÷ 32e if w = CREATE2
Gsha3 + Gsha3word × dµs
[1] ÷ 32e if w = SHA3
Gjumpdest if w = JUMPDEST
Gsload if w = SLOAD
Gzero if w ∈ Wzero
Gbase if w ∈ Wbase
Gverylow if w ∈ Wverylow
Glow if w ∈ Wlow
Gmid if w ∈ Wmid
Ghigh if w ∈ Whigh
Gextcode if w = EXTCODESIZE
Gextcodehash if w = EXTCODEHASH
Gbalance if w = BALANCE
Gblockhash if w = BLOCKHASH
(297) w ≡
(
Ib[µpc] if µpc < kIbk
STOP otherwise
where:
(298) Cmem(a) ≡ Gmemory · a +

a
2
512
with CCALL, CSELFDESTRUCT and CSSTORE as specified in the appropriate section below. We define the following subsets
of instructions:
Wzero = {STOP, RETURN, REVERT}
Wbase = {ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, COINBASE,
TIMESTAMP, NUMBER, DIFFICULTY, GASLIMIT, RETURNDATASIZE, POP, PC, MSIZE, GAS}
Wverylow = {ADD, SUB, NOT, LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, BYTE, SHL, SHR, SAR,
CALLDATALOAD, MLOAD, MSTORE, MSTORE8, PUSH*, DUP*, SWAP*}
Wlow = {MUL, DIV, SDIV, MOD, SMOD, SIGNEXTEND}
Wmid = {ADDMOD, MULMOD, JUMP}
Whigh = {JUMPI}
Note the memory cost component, given as the product of Gmemory and the maximum of 0 & the ceiling of the number
of words in size that the memory must be over the current number of words, µi
in order that all accesses reference valid
memory whether for read or write. Such accesses must be for non-zero number of bytes.
Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory
to be extended to the beginning of the range. µ
0
i
is defined as this new maximum number of words of active memory;
special-cases are given where these two are not equal.
Note also that Cmem is the memory cost function (the expansion function being the difference between the cost before
and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 724B of memory
used, after which it costs substantially more.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 27
While defining the instruction set, we defined the memory-expansion for range function, M, thus:
(299) M(s, f, l) ≡
(
s if l = 0
max(s, d(f + l) ÷ 32e) otherwise
Another useful function is “all but one 64th” function L defined as:
(300) L(n) ≡ n − bn/64c
H.2. Instruction Set. As previously specified in section 9, these definitions take place in the final context there. In
particular we assume O is the EVM state-progression function and define the terms pertaining to the next cycle’s state
(σ
0
, µ
0
) such that:
(301) O(σ, µ, A, I) ≡ (σ
0
, µ
0
, A0
, I) with exceptions, as noted
Here given are the various exceptions to the state transition rules given in section 9 specified for each instruction,
together with the additional instruction-specific definitions of J and C. For each instruction, also specified is α, the
additional items placed on the stack and δ, the items removed from stack, as defined in section 9.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 28
0s: Stop and Arithmetic Operations
All arithmetic is modulo 2256 unless otherwise noted. The zero-th power of zero 00
is defined to be one.
Value Mnemonic δ α Description
0x00 STOP 0 0 Halts execution.
0x01 ADD 2 1 Addition operation.
µ
0
s
[0] ≡ µs
[0] + µs
[1]
0x02 MUL 2 1 Multiplication operation.
µ
0
s
[0] ≡ µs
[0] × µs
[1]
0x03 SUB 2 1 Subtraction operation.
µ
0
s
[0] ≡ µs
[0] − µs
[1]
0x04 DIV 2 1 Integer division operation.
µ
0
s
[0] ≡
(
0 if µs
[1] = 0
bµs
[0] ÷ µs
[1]c otherwise
0x05 SDIV 2 1 Signed integer division operation (truncated).
µ
0
s
[0] ≡



0 if µs
[1] = 0
−2
255 if µs
[0] = −2
255 ∧ µs
[1] = −1
sgn(µs
[0] ÷ µs
[1])b|µs
[0] ÷ µs
[1]|c otherwise
Where all values are treated as two’s complement signed 256-bit integers.
Note the overflow semantic when −2
255 is negated.
0x06 MOD 2 1 Modulo remainder operation.
µ
0
s
[0] ≡
(
0 if µs
[1] = 0
µs
[0] mod µs
[1] otherwise
0x07 SMOD 2 1 Signed modulo remainder operation.
µ
0
s
[0] ≡
(
0 if µs
[1] = 0
sgn(µs
[0])(|µs
[0]| mod |µs
[1]|) otherwise
Where all values are treated as two’s complement signed 256-bit integers.
0x08 ADDMOD 3 1 Modulo addition operation.
µ
0
s
[0] ≡
(
0 if µs
[2] = 0
(µs
[0] + µs
[1]) mod µs
[2] otherwise
All intermediate calculations of this operation are not subject to the 2256
modulo.
0x09 MULMOD 3 1 Modulo multiplication operation.
µ
0
s
[0] ≡
(
0 if µs
[2] = 0
(µs
[0] × µs
[1]) mod µs
[2] otherwise
All intermediate calculations of this operation are not subject to the 2256
modulo.
0x0a EXP 2 1 Exponential operation.
µ
0
s
[0] ≡ µs
[0]µs
[1]
0x0b SIGNEXTEND 2 1 Extend length of two’s complement signed integer.
∀i ∈ [0..255] : µ
0
s
[0]i ≡
(
µs
[1]t if i 6 t where t = 256 − 8(µs
[0] + 1)
µs
[1]i otherwise
µs
[x]i gives the ith bit (counting from zero) of µs
[x]
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 29
10s: Comparison & Bitwise Logic Operations
Value Mnemonic δ α Description
0x10 LT 2 1 Less-than comparison.
µ
0
s
[0] ≡
(
1 if µs
[0] < µs
[1]
0 otherwise
0x11 GT 2 1 Greater-than comparison.
µ
0
s
[0] ≡
(
1 if µs
[0] > µs
[1]
0 otherwise
0x12 SLT 2 1 Signed less-than comparison.
µ
0
s
[0] ≡
(
1 if µs
[0] < µs
[1]
0 otherwise
Where all values are treated as two’s complement signed 256-bit integers.
0x13 SGT 2 1 Signed greater-than comparison.
µ
0
s
[0] ≡
(
1 if µs
[0] > µs
[1]
0 otherwise
Where all values are treated as two’s complement signed 256-bit integers.
0x14 EQ 2 1 Equality comparison.
µ
0
s
[0] ≡
(
1 if µs
[0] = µs
[1]
0 otherwise
0x15 ISZERO 1 1 Simple not operator.
µ
0
s
[0] ≡
(
1 if µs
[0] = 0
0 otherwise
0x16 AND 2 1 Bitwise AND operation.
∀i ∈ [0..255] : µ
0
s
[0]i ≡ µs
[0]i ∧ µs
[1]i
0x17 OR 2 1 Bitwise OR operation.
∀i ∈ [0..255] : µ
0
s
[0]i ≡ µs
[0]i ∨ µs
[1]i
0x18 XOR 2 1 Bitwise XOR operation.
∀i ∈ [0..255] : µ
0
s
[0]i ≡ µs
[0]i ⊕ µs
[1]i
0x19 NOT 1 1 Bitwise NOT operation.
∀i ∈ [0..255] : µ
0
s
[0]i ≡
(
1 if µs
[0]i = 0
0 otherwise
0x1a BYTE 2 1 Retrieve single byte from word.
∀i ∈ [0..255] : µ
0
s
[0]i ≡
(
µs
[1](i+8µs
[0]) if i < 8 ∧ µs
[0] < 32
0 otherwise
For the Nth byte, we count from the left (i.e. N=0 would be the most significant
in big endian).
0x1b SHL 2 1 Left shift operation.
µ
0
s
[0] ≡ (µs
[1] × 2
µs
[0]) mod 2256
0x1c SHR 2 1 Logical right shift operation.
µ
0
s
[0] ≡ bµs
[1] ÷ 2
µs
[0]c
0x1d SAR 2 1 Arithmetic (signed) right shift operation.
µ
0
s
[0] ≡ bµs
[1] ÷ 2
µs
[0]c
Where µ
0
s
[0] and µs
[1] are treated as two’s complement signed 256-bit integers,
while µs
[0] is treated as unsigned.
20s: SHA3
Value Mnemonic δ α Description
0x20 SHA3 2 1 Compute Keccak-256 hash.
µ
0
s
[0] ≡ KEC(µm[µs
[0] . . .(µs
[0] + µs
[1] − 1)])
µ
0
i ≡ M(µi
, µs
[0], µs
[1])
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 30
30s: Environmental Information
Value Mnemonic δ α Description
0x30 ADDRESS 0 1 Get address of currently executing account.
µ
0
s
[0] ≡ Ia
0x31 BALANCE 1 1 Get balance of the given account.
µ
0
s
[0] ≡
(
σ[µs
[0]]b if σ[µs
[0] mod 2160] 6= ∅
0 otherwise
0x32 ORIGIN 0 1 Get execution origination address.
µ
0
s
[0] ≡ Io
This is the sender of original transaction; it is never an account with
non-empty associated code.
0x33 CALLER 0 1 Get caller address.
µ
0
s
[0] ≡ Is
This is the address of the account that is directly responsible for
this execution.
0x34 CALLVALUE 0 1 Get deposited value by the instruction/transaction responsible for
this execution.
µ
0
s
[0] ≡ Iv
0x35 CALLDATALOAD 1 1 Get input data of current environment.
µ
0
s
[0] ≡ Id[µs
[0] . . .(µs
[0] + 31)] with Id[x] = 0 if x > kIdk
This pertains to the input data passed with the message call
instruction or transaction.
0x36 CALLDATASIZE 0 1 Get size of input data in current
environment.
µ
0
s
[0] ≡ kIdk
This pertains to the input data passed with the message call
instruction or transaction.
0x37 CALLDATACOPY 3 0 Copy input data in current environment to memory.
∀i ∈ {0 . . . µs
[2] − 1} : µ
0
m[µs
[0] + i] ≡
(
Id[µs
[1] + i] if µs
[1] + i < kIdk
0 otherwise
The additions in µs
[1] + i are not subject to the 2256 modulo.
µ
0
i ≡ M(µi
, µs
[0], µs
[2])
This pertains to the input data passed with the message call instruction
or transaction.
0x38 CODESIZE 0 1 Get size of code running in current environment.
µ
0
s
[0] ≡ kIbk
0x39 CODECOPY 3 0 Copy code running in current environment to memory.
∀i ∈ {0 . . . µs
[2] − 1} : µ
0
m[µs
[0] + i] ≡
(
Ib[µs
[1] + i] if µs
[1] + i < kIbk
STOP otherwise
µ
0
i ≡ M(µi
, µs
[0], µs
[2])
The additions in µs
[1] + i are not subject to the 2256 modulo.
0x3a GASPRICE 0 1 Get price of gas in current environment.
µ
0
s
[0] ≡ Ip
This is gas price specified by the originating transaction.
0x3b EXTCODESIZE 1 1 Get size of an account’s code.
µ
0
s
[0] ≡ kbk
where KEC(b) ≡ σ[µs
[0] mod 2160]c
0x3c EXTCODECOPY 4 0 Copy an account’s code to memory.
∀i ∈ {0 . . . µs
[3] − 1} : µ
0
m[µs
[1] + i] ≡
(
b[µs
[2] + i] if µs
[2] + i < kbk
STOP otherwise
where KEC(b) ≡ σ[µs
[0] mod 2160]c
µ
0
i ≡ M(µi
, µs
[1], µs
[3])
The additions in µs
[2] + i are not subject to the 2256 modulo.
0x3d RETURNDATASIZE 0 1 Get size of output data from the previous call from the current
environment.
µ
0
s
[0] ≡ kµok
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 31
0x3e RETURNDATACOPY 3 0 Copy output data from the previous call to memory.
∀i ∈ {0 . . . µs
[2] − 1} : µ
0
m[µs
[0] + i] ≡
(
µo
[µs
[1] + i] if µs
[1] + i < kµok
0 otherwise
The additions in µs
[1] + i are not subject to the 2256 modulo.
µ
0
i ≡ M(µi
, µs
[0], µs
[2])
0x3f EXTCODEHASH 1 1 Get hash of an account’s code.
µ
0
s
[0] ≡
(
0 if DEAD(σ, µs
[0] mod 2160)
σ[µs
[0] mod 2160]c otherwise
40s: Block Information
Value Mnemonic δ α Description
0x40 BLOCKHASH 1 1 Get the hash of one of the 256 most recent complete blocks.
µ
0
s
[0] ≡ P(IHp
, µs
[0], 0)
where P is the hash of a block of a particular number, up to a maximum
age. 0 is left on the stack if the looked for block number is greater than
the current block number or more than 256 blocks behind the current block.
P(h, n, a) ≡



0 if n > Hi ∨ a = 256 ∨ h = 0
h if n = Hi
P(Hp, n, a + 1) otherwise
and we assert the header H can be determined from its hash h unless h is zero
(as is the case for the parent hash of the genesis block).
0x41 COINBASE 0 1 Get the block’s beneficiary address.
µ
0
s
[0] ≡ IHc
0x42 TIMESTAMP 0 1 Get the block’s timestamp.
µ
0
s
[0] ≡ IHs
0x43 NUMBER 0 1 Get the block’s number.
µ
0
s
[0] ≡ IHi
0x44 DIFFICULTY 0 1 Get the block’s difficulty.
µ
0
s
[0] ≡ IHd
0x45 GASLIMIT 0 1 Get the block’s gas limit.
µ
0
s
[0] ≡ IHl
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 32
50s: Stack, Memory, Storage and Flow Operations
Value Mnemonic δ α Description
0x50 POP 1 0 Remove item from stack.
0x51 MLOAD 1 1 Load word from memory.
µ
0
s
[0] ≡ µm[µs
[0] . . .(µs
[0] + 31)]
µ
0
i ≡ max(µi
, d(µs
[0] + 32) ÷ 32e)
The addition in the calculation of µ
0
i
is not subject to the 2256 modulo.
0x52 MSTORE 2 0 Save word to memory.
µ
0
m[µs
[0] . . .(µs
[0] + 31)] ≡ µs
[1]
µ
0
i ≡ max(µi
, d(µs
[0] + 32) ÷ 32e)
The addition in the calculation of µ
0
i
is not subject to the 2256 modulo.
0x53 MSTORE8 2 0 Save byte to memory.
µ
0
m[µs
[0]] ≡ (µs
[1] mod 256)
µ
0
i ≡ max(µi
, d(µs
[0] + 1) ÷ 32e)
The addition in the calculation of µ
0
i
is not subject to the 2256 modulo.
0x54 SLOAD 1 1 Load word from storage.
µ
0
s
[0] ≡ σ[Ia]s[µs
[0]]
0x55 SSTORE 2 0 Save word to storage.
σ
0
[Ia]s[µs
[0]] ≡ µs
[1]
CSSTORE(σ, µ) ≡
(
Gsset if µs
[1] 6= 0 ∧ σ[Ia]s[µs
[0]] = 0
Gsreset otherwise
A
0
r ≡ Ar +
(
Rsclear if µs
[1] = 0 ∧ σ[Ia]s[µs
[0]] 6= 0
0 otherwise
0x56 JUMP 1 0 Alter the program counter.
JJUMP(µ) ≡ µs
[0]
This has the effect of writing said value to µpc. See section 9.
0x57 JUMPI 2 0 Conditionally alter the program counter.
JJUMPI(µ) ≡
(
µs
[0] if µs
[1] 6= 0
µpc + 1 otherwise
This has the effect of writing said value to µpc. See section 9.
0x58 PC 0 1 Get the value of the program counter prior to the increment
corresponding to this instruction.
µ
0
s
[0] ≡ µpc
0x59 MSIZE 0 1 Get the size of active memory in bytes.
µ
0
s
[0] ≡ 32µi
0x5a GAS 0 1 Get the amount of available gas, including the corresponding reduction
for the cost of this instruction.
µ
0
s
[0] ≡ µg
0x5b JUMPDEST 0 0 Mark a valid destination for jumps.
This operation has no effect on machine state during execution.
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 33
60s & 70s: Push Operations
Value Mnemonic δ α Description
0x60 PUSH1 0 1 Place 1 byte item on stack.
µ
0
s
[0] ≡ c(µpc + 1)
where c(x) ≡
(
Ib[x] if x < kIbk
0 otherwise
The bytes are read in line from the program code’s bytes array.
The function c ensures the bytes default to zero if they extend past the limits.
The byte is right-aligned (takes the lowest significant place in big endian).
0x61 PUSH2 0 1 Place 2-byte item on stack.
µ
0
s
[0] ≡ c

(µpc + 1). . .(µpc + 2)
with c(x) ≡ (c(x0), ..., c(xkxk−1)) with c as defined as above.
The bytes are right-aligned (takes the lowest significant place in big endian).
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0x7f PUSH32 0 1 Place 32-byte (full word) item on stack.
µ
0
s
[0] ≡ c

(µpc + 1). . .(µpc + 32)
where c is defined as above.
The bytes are right-aligned (takes the lowest significant place in big endian).
80s: Duplication Operations
Value Mnemonic δ α Description
0x80 DUP1 1 2 Duplicate 1st stack item.
µ
0
s
[0] ≡ µs
[0]
0x81 DUP2 2 3 Duplicate 2nd stack item.
µ
0
s
[0] ≡ µs
[1]
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0x8f DUP16 16 17 Duplicate 16th stack item.
µ
0
s
[0] ≡ µs
[15]
90s: Exchange Operations
Value Mnemonic δ α Description
0x90 SWAP1 2 2 Exchange 1st and 2nd stack items.
µ
0
s
[0] ≡ µs
[1]
µ
0
s
[1] ≡ µs
[0]
0x91 SWAP2 3 3 Exchange 1st and 3rd stack items.
µ
0
s
[0] ≡ µs
[2]
µ
0
s
[2] ≡ µs
[0]
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0x9f SWAP16 17 17 Exchange 1st and 17th stack items.
µ
0
s
[0] ≡ µs
[16]
µ
0
s
[16] ≡ µs
[
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 34
a0s: Logging Operations
For all logging operations, the state change is to append an additional log entry on to the substate’s log series:
A
0
l ≡ Al · (Ia, t, µm[µs
[0] . . .(µs
[0] + µs
[1] − 1)])
and to update the memory consumption counter:
µ
0
i ≡ M(µi
, µs
[0], µs
[1])
The entry’s topic series, t, differs accordingly:
Value Mnemonic δ α Description
0xa0 LOG0 2 0 Append log record with no topics.
t ≡ ()
0xa1 LOG1 3 0 Append log record with one topic.
t ≡ (µs
[2])
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
0xa4 LOG4 6 0 Append log record with four topics.
t ≡ (µs
[2], µs
[3], µs
[4], µs
[5])
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 35
f0s: System operations
Value Mnemonic δ α Description
0xf0 CREATE 3 1 Create a new account with associated code.
i ≡ µm[µs
[1] . . .(µs
[1] + µs
[2] − 1)]
ζ ≡ ∅
(σ
0
, µ
0
g
, A+, o) ≡



Λ(σ
∗
, Ia, Io, L(µg
), Ip, µs
[0], i, Ie + 1, ζ, Iw) if µs
[0] 6 σ[Ia]b
∧ Ie < 1024

σ, µg
, ∅

otherwise
σ
∗ ≡ σ except σ
∗
[Ia]n = σ[Ia]n + 1
A
0 ≡ A d A
+ which abbreviates: A
0
s ≡ As ∪ A
+
s ∧ A
0
l ≡ Al · A
+
l ∧
A
0
t ≡ At ∪ A
+
t ∧ A
0
r ≡ Ar + A
+
r
µ
0
s
[0] ≡ x
where x = 0 if the code execution for this operation failed due to an
exceptional halting (or for a REVERT) σ
0 = ∅, or Ie = 1024
(the maximum call depth limit is reached) or µs
[0] > σ[Ia]b (balance of the caller
is too low to fulfil the value transfer); and otherwise x = A(Ia, σ[Ia]n, ζ, i), the
address of the newly created account (79).
µ
0
i ≡ M(µi
, µs
[1], µs
[2])
µ
0
o ≡ ()
Thus the operand order is: value, input offset, input size.
0xf1 CALL 7 1 Message-call into an account.
i ≡ µm[µs
[3] . . .(µs
[3] + µs
[4] − 1)]
(σ
0
, g0
, A+, o) ≡



Θ(σ, Ia, Io, t, t, CCALLGAS(µ),
Ip, µs
[2], µs
[2], i, Ie + 1, Iw)
if µs
[2] 6 σ[Ia]b ∧
Ie < 1024
(σ, g, ∅,()) otherwise
n ≡ min({µs
[6], kok})
µ
0
m[µs
[5] . . .(µs
[5] + n − 1)] = o[0 . . .(n − 1)]
µ
0
o = o
µ
0
g ≡ µg + g
0
µ
0
s
[0] ≡ x
A
0 ≡ A d A
+
t ≡ µs
[1] mod 2160
where x = 0 if the code execution for this operation failed due to an
exceptional halting (or for a REVERT) σ
0 = ∅ or if
µs
[2] > σ[Ia]b (not enough funds) or Ie = 1024 (call depth limit reached); x = 1
otherwise.
µ
0
i ≡ M(M(µi
, µs
[3], µs
[4]), µs
[5], µs
[6])
Thus the operand order is: gas, to, value, in offset, in size, out offset, out size.
CCALL(σ, µ) ≡ CGASCAP(σ, µ) + CEXTRA(σ, µ)
CCALLGAS(σ, µ) ≡
(
CGASCAP(σ, µ) + Gcallstipend if µs
[2] 6= 0
CGASCAP(σ, µ) otherwise
CGASCAP(σ, µ) ≡
(
min{L(µg − CEXTRA(σ, µ)), µs
[0]} if µg ≥ CEXTRA(σ, µ)
µs
[0] otherwise
CEXTRA(σ, µ) ≡ Gcall + CXFER(µ) + CNEW(σ, µ)
CXFER(µ) ≡
(
Gcallvalue if µs
[2] 6= 0
0 otherwise
CNEW(σ, µ) ≡
(
Gnewaccount if DEAD(σ, µs
[1] mod 2160) ∧ µs
[2] 6= 0
0 otherwise
0xf2 CALLCODE 7 1 Message-call into this account with an alternative account’s code.
Exactly equivalent to CALL except:
(σ
0
, g0
, A+, o) ≡



Θ(σ
∗
, Ia, Io, Ia, t, CCALLGAS(µ),
Ip, µs
[2], µs
[2], i, Ie + 1, Iw)
if µs
[2] 6 σ[Ia]b ∧
Ie < 1024
(σ, g, ∅,()) otherwise
Note the change in the fourth parameter to the call Θ from the 2nd stack value
µs
[1] (as in CALL) to the present address Ia. This means that the recipient is in
fact the same account as at present, simply that the code is overwritten.
0xf3 RETURN 2 0 Halt execution returning output data.
HRETURN(µ) ≡ µm[µs
[0] . . .(µs
[0] + µs
[1] − 1)]
This has the effect of halting the execution at this point with output defined.
See section 9.
µ
0
i ≡ M(µi
, µs
[0], µs
[1]
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 36
0xf4 DELEGATECALL 6 1 Message-call into this account with an alternative account’s code, but
persisting the current values for sender and value.
Compared with CALL, DELEGATECALL takes one fewer arguments. The
omitted argument is µs
[2]. As a result, µs
[3], µs
[4], µs
[5] and µs
[6] in the
definition of CALL should respectively be replaced with µs
[2], µs
[3], µs
[4] and
µs
[5]. Otherwise it is equivalent to CALL except:
(σ
0
, g0
, A+, o) ≡



Θ(σ
∗
, Is, Io, Ia, t, CCALLGAS(µ),
Ip, 0, Iv, i, Ie + 1, Iw)
if Iv 6 σ[Ia]b ∧
Ie < 1024
(σ, g, ∅,()) otherwise
Note the changes (in addition to that of the fourth parameter) to the second
and ninth parameters to the call Θ.
This means that the recipient is in fact the same account as at present, simply
that the code is overwritten and the context is almost entirely identical.
0xf5 CREATE2 4 1 Create a new account with associated code.
Exactly equivalent to CREATE except:
The salt ζ ≡ µs
[3].
0xfa STATICCALL 6 1 Static message-call into an account.
Exactly equivalent to CALL except:
The argument µs
[2] is replaced with 0.
The deeper argument µs
[3], µs
[4], µs
[5] and µs
[6] are respectively replaced
with µs
[2], µs
[3], µs
[4] and µs
[5].
The last argument of Θ is ⊥.
0xfd REVERT 2 0 Halt execution reverting state changes but returning data and remaining gas.
The effect of this operation is described in (133).
For the gas calculation, we use the memory expansion function,
µ
0
i ≡ M(µi
, µs
[0], µs
[1])
0xfe INVALID ∅ ∅ Designated invalid instruction.
0xff SELFDESTRUCT 1 0 Halt execution and register account for later deletion.
A
0
s ≡ As ∪ {Ia}
σ
0
[r] ≡



∅ if σ[r] = ∅ ∧ σ[Ia]b = 0
(σ[r]n, σ[r]b + σ[Ia]b, σ[r]s, σ[r]c) if r 6= Ia
(σ[r]n, 0, σ[r]s, σ[r]c) otherwise
where r = µs
[0] mod 2160
σ
0
[Ia]b = 0
CSELFDESTRUCT(σ, µ) ≡ Gselfdestruct +
(
Gnewaccount if n
0 otherwise
n ≡ DEAD(σ, µs
[0] mod 2160) ∧ σ[Ia]b 6= 0
Appendix I. Genesis Block
The genesis block is 15 items, and is specified thus:
(302) 0256, KEC
RLP
(), 0160, stateRoot, 0, 0, 02048, 2
17
, 0, 0, 3141592, time, 0, 0256, KEC
(42),(),()
Where 0256 refers to the parent hash, a 256-bit hash which is all zeroes; 0160 refers to the beneficiary address, a 160-bit
hash which is all zeroes; 02048 refers to the log bloom, 2048-bit of all zeros; 217 refers to the difficulty; the transaction trie
root, receipt trie root, gas used, block number and extradata are both 0, being equivalent to the empty byte array. The
sequences of both ommers and transactions are empty and represented by (). KEC
(42)
refers to the Keccak hash of a
byte array of length one whose first and only byte is of value 42, used for the nonce. KEC
RLP
() value refers to the
hash of the ommer list in RLP, both empty lists.
The proof-of-concept series include a development premine, making the state root hash some value stateRoot. Also
time will be set to the initial timestamp of the genesis block. The latest documentation should be consulted for those
values.
Appendix J. Ethash
J.1. Definitions. We employ the following defi
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 37
Name Value Description
Jwordbytes 4 Bytes in word.
Jdatasetinit 2
30 Bytes in dataset at genesis.
Jdatasetgrowth 2
23 Dataset growth per epoch.
Jcacheinit 2
24 Bytes in cache at genesis.
Jcachegrowth 2
17 Cache growth per epoch.
Jepoch 30000 Blocks per epoch.
Jmixbytes 128 mix length in bytes.
Jhashbytes 64 Hash length in bytes.
Jparents 256 Number of parents of each dataset element.
Jcacherounds 3 Number of rounds in cache production.
Jaccesses 64 Number of accesses in hashimoto loop.
J.2. Size of dataset and cache. The size for Ethash’s cache c ∈ B and dataset d ∈ B depend on the epoch, which in
turn depends on the block number.
(303) Eepoch(Hi) = 
Hi
Jepoch 
The size of the dataset growth by Jdatasetgrowth bytes, and the size of the cache by Jcachegrowth bytes, every epoch. In
order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a
multiple of Jmixbytes, for the dataset, and Jhashbytes for the cache. Let dsize = kdk be the size of the dataset. Which is
calculated using
(304) dsize = Eprime(Jdatasetinit + Jdatasetgrowth · Eepoch − Jmixbytes, Jmixbytes)
The size of the cache, csize, is calculated using
(305) csize = Eprime(Jcacheinit + Jcachegrowth · Eepoch − Jhashbytes, Jhashbytes)
(306) Eprime(x, y) = (
x if x/y ∈ N
Eprime(x − 2 · y, y) otherwise
J.3. Dataset generation. In order to generate the dataset we need the cache c, which is an array of bytes. It depends
on the cache size csize and the seed hash s ∈ B32.
J.3.1. Seed hash. The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32
bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
(307) s = Cseedhash(Hi)
(308) Cseedhash(Hi) = (
032 if Eepoch(Hi) = 0
KEC(Cseedhash(Hi − Jepoch)) otherwise
With 032 being 32 bytes of zeros.
J.3.2. Cache. The cache production process involves using the seed hash to first sequentially filling up csize bytes of
memory, then performing Jcacherounds passes of the RandMemoHash algorithm created by Lerner [2014]. The initial
cache c
0
, being an array of arrays of single bytes, will be constructed as follows.
We define the array ci, consisting of 64 single bytes, as the ith element of the initial cache:
(309) ci =
(
KEC512(s) if i = 0
KEC512(ci−1) otherwise
Therefore c
0
can be defined as
(310) c
0
[i] = ci ∀ i < n
(311) n =

csize
Jhashbytes 
The cache is calculated by performing Jcacherounds rounds of the RandMemoHash algorithm to the initial cache c
0
:
(312) c = Ecacherounds(c
0
, Jcacherounds)
(313) Ecacherounds(x, y) =



x if y = 0
ERMH(x) if y = 1
Ecacherounds(ERMH(x), y − 1) otherwise
Where a single round modifies each subset of the cache as follows:
(314) ERMH(x) =
Ermh(x, 0), Ermh(x, 1), ..., Ermh(x, n − 1)
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 38
(315) Ermh(x, i) = KEC512(x
0
[(i − 1 + n) mod n] ⊕ x
0
[x
0
[i][0] mod n])
with x
0 = x except x
0
[j] = Ermh(x, j) ∀ j < i
J.3.3. Full dataset calculation. Essentially, we combine data from Jparents pseudorandomly selected cache nodes, and hash
that to compute the dataset. The entire dataset is then generated by a number of items, each Jhashbytes bytes in size:
(316) d[i] = Edatasetitem(c, i) ∀ i < 
dsize
Jhashbytes 
In order to calculate the single item we use an algorithm inspired by the FNV hash (Glenn Fowler [1991]) in some cases
as a non-associative substitute for XOR.
(317) EFNV(x, y) = (x · (0x01000193 ⊕ y)) mod 232
The single item of the dataset can now be calculated as:
(318) Edatasetitem(c, i) = Eparents(c, i, −1, ∅)
(319) Eparents(c, i, p, m) = (
Eparents(c, i, p + 1, Emix(m, c, i, p + 1)) if p < Jparents − 2
Emix(m, c, i, p + 1) otherwise
(320) Emix(m, c, i, p) = (
KEC512(c[i mod csize] ⊕ i) if p = 0
EFNV
m, c[EFNV(i ⊕ p, m[p mod bJhashbytes/Jwordbytesc]) mod csize]

otherwise
J.4. Proof-of-work function. Essentially, we maintain a “mix” Jmixbytes bytes wide, and repeatedly sequentially fetch
Jmixbytes bytes from the full dataset and use the EFNV function to combine it with the mix. Jmixbytes bytes of sequential
access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside
buffer misses which ASICs would theoretically be able to avoid.
If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application
of KEC at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small
amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide
statistical assurance that the result is an unbiased, 256 bit number.
The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the
concatenation of the compressed mix with the seed hash as the second item:
(321)
PoW(Hn, Hn, d) = {mc(KEC(RLP(LH(Hn))), Hn, d), KEC(sh(KEC(RLP(LH(Hn))), Hn) + mc(KEC(RLP(LH(Hn))), Hn, d))}
With Hn being the hash of the header without the nonce. The compressed mix mc is obtained as follows:
(322) mc(h, n, d) = Ecompress(Eaccesses(d,
nXmix
i=0
sh(h, n), sh(h, n), −1), −4)
The seed hash being:
(323) sh(h, n) = KEC512(h + Erevert(n))
Erevert(n) returns the reverted bytes sequence of the nonce n:
(324) Erevert(n)[i] = n[knk − i]
We note that the “+”-operator between two byte sequences results in the concatenation of both sequences.
The dataset d is obtained as described in section J.3.3.
The number of replicated sequences in the mix is:
(325) nmix =

Jmixbytes
Jhashbytes 
In order to add random dataset nodes to the mix, the Eaccesses function is used:
(326) Eaccesses(d, m, s, i) = (
Emixdataset(d, m, s, i) if i = Jaccesses − 2
Eaccesses(Emixdataset(d, m, s, i), s, i + 1) otherwise
(327) Emixdataset(d, m, s, i) = EFNV(m, Enewdata(d, m, s, i))
Enewdata returns an array with nmix elements:
(328)
Enewdata(d, m, s, i)[j] = d[EFNV(i ⊕ s[0], m[i mod 
Jmixbytes
Jwordbytes 
]) mod 
dsize/Jhashbytes
nmix 
· nmix + j] ∀ j < nmix
The mix is compressed as follows:
(329)
Ecompress(m, i) = (
m if i > kmk − 8
Ecompress(EFNV(EFNV(EFNV(m[i + 4], m[i + 5]), m[i + 6]), m[i + 7]), i + 8) otherwis
ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER 39
Appendix K. Anomalies on the Main Network
K.1. Deletion of an Account Despite Out-of-gas. At block 2675119, in the transaction 0xcf416c536ec1a19ed1fb89e
4ec7ffb3cf73aa413b3aa9b77d60e4fd81a4296ba, an account at address 0x03 was called and an out-of-gas occurred during
the call. Against the equation (197), this added 0x03 in the set of touched addresses, and this transaction turned σ[0x03]
into ∅.
Appendix L. List of mathematical symbols
Symbol Latex Command Description
W
\bigvee This is the least upper bound, supremum, or join of all elements operated on. Thus it
is the greatest element of such elements (Davey and Priestley [2002]).</p>
</section>
  <script type="text/javascript">
    let progress = document.getElementById('progressbar');
    let totalHeight = document.body.scrollHeight - window.innerHeight;
    window.onscroll = function(){
      let progressHeight = (window.pageYOffset / totalHeight) * 100;
      progress.style.height = progressHeight + "%";
    }
  </script>
</body>
</html>